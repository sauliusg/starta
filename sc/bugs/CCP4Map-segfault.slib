//--*- C -*------------------------------------------------------------------*\
//$Author: saulius $
//$Date: 2012-01-24 11:08:59 +0200 (Tue, 24 Jan 2012) $ 
//$Revision: 3 $
//$URL: svn+ssh://saulius-grazulis.lt/home/saulius/svn-repositories/sgem-xray/trunk/lib/CCP4Map.slib $
//---------------------------------------------------------------------------*/
//*
// Read, write and transformation functions for the CCP4 map files.
//**

package CCP4Map;

// Segfaults when 'std' package is not used:
// use std;

/*
# From /xray/install/ccp4/ccp4-6.2.0-bin/doc/maplib.doc, line 81:
#
# 2) DETAILED DESCRIPTION OF THE MAP FORMAT
# 
#    The overall layout of the file is as follows:
#     1. File header (256 longwords)
#     2. Symmetry information
#     3. Map, stored as a 3-dimensional array
# 
#    The header is organised as 56 words followed by space for ten 80
#    character text labels as follows:
# 
#  1      NC              # of Columns    (fastest changing in map)
#  2      NR              # of Rows
#  3      NS              # of Sections   (slowest changing in map)
#  4      MODE            Data type
#                           0 = envelope stored as signed bytes (from
#                               -128 lowest to 127 highest)
#                           1 = Image     stored as Integer*2
#                           2 = Image     stored as Reals
#                           3 = Transform stored as Complex Integer*2
#                           4 = Transform stored as Complex Reals
#                           5 == 0
# 
#                           Note: Mode 2 is the normal mode used in
#                                 the CCP4 programs. Other modes than 2 and 0
#                                 may NOT WORK
# 
#  5      NCSTART         Number of first COLUMN  in map
#  6      NRSTART         Number of first ROW     in map
#  7      NSSTART         Number of first SECTION in map
#  8      NX              Number of intervals along X
#  9      NY              Number of intervals along Y
# 10      NZ              Number of intervals along Z
# 11      X length        Cell Dimensions (Angstroms)
# 12      Y length                     "
# 13      Z length                     "
# 14      Alpha           Cell Angles     (Degrees)
# 15      Beta                         "
# 16      Gamma                        "
# 17      MAPC            Which axis corresponds to Cols.  (1,2,3 for X,Y,Z)
# 18      MAPR            Which axis corresponds to Rows   (1,2,3 for X,Y,Z)
# 19      MAPS            Which axis corresponds to Sects. (1,2,3 for X,Y,Z)
# 20      AMIN            Minimum density value
# 21      AMAX            Maximum density value
# 22      AMEAN           Mean    density value    (Average)
# 23      ISPG            Space group number
# 24      NSYMBT          Number of bytes used for storing symmetry operators
# 25      LSKFLG          Flag for skew transformation, =0 none, =1 if foll
# 26-34   SKWMAT          Skew matrix S (in order S11, S12, S13, S21 etc) if
#                         LSKFLG .ne. 0.
# 35-37   SKWTRN          Skew translation t if LSKFLG .ne. 0.
#                         Skew transformation is from standard orthogonal
#                         coordinate frame (as used for atoms) to orthogonal
#                         map frame, as
# 
#                                 Xo(map) = S * (Xo(atoms) - t)
# 
# 38      future use       (some of these are used by the MSUBSX routines
#  .          "              in MAPBRICK, MAPCONT and FRODO)
#  .          "   (all set to zero by default)
#  .          "
# 52          "
# 
# 53      MAP             Character string 'MAP ' to identify file type
# 54      MACHST          Machine stamp indicating the machine type
#                         which wrote file
# 55      ARMS            Rms deviation of map from mean density
# 56      NLABL           Number of labels being used
# 57-256  LABEL(20,10)    10  80 character text labels (ie. A4 format)
# 
# 
#    Symmetry records follow - if any - stored as text as in International
#    Tables, operators separated by * and grouped into 'lines' of 80
#    characters (i.e. symmetry operators do not cross the ends of the
#    80-character 'lines' and the 'lines' do not terminate in a *).
# 
#    Map data array follows.
*/

/*
From /xray/install/ccp4/ccp4-6.0.0/doc/library.doc lines 156-177/875:

  Machine stamps

   The  machine  stamp  is  a  32-bit  quantity  containing a set of four
   `nibbles' (half-bytes)---only half the space is used. Each nibble is a
   number  specifying  the  representation  of  (in C terms) double (d) ,
   float  (f), int (i) and unsigned char (c) types. Thus each stamp is of
   the  form 0xdfic0000. The values for the floating point nibbles may be
   taken from the list (following HDF):

   1 Big-endian ieee
   2 VAX
   3 Cray
   4 Little-endian ieee
   5 Convex native
   6 Fijitsu VP

   The Cray isn't relevant to us because it's not a 32-bit machine and we
   don't   currently  have  a  use  for  the  Fujitsu  one,  which  isn't
   implemented  here.  We  ignore the possibility of non-ascii characters
   which  might need converting e.g., from ebcdic, so c is always 1; also
   f  and d are the same (as per Fortran). See the HDF code for character
   code possibilities.

   Here are the tags for different formats as used in the code.

   class info codes for int
   DFNTI_MBO                  1 Motorola byte order 2's compl
   DFNTI_IBO                  4 Intel byte order 2's compl
   class info codes for float
   DFNTF_BEIEEE               1 big endian IEEE (canonical)
   FNTF_VAX                   2 Vax format
   DFNTF_CONVEXNATIVE         5 Convex native floats
   DFNTF_LEIEEE               4 little-endian IEEE format
*/

/* class codes taken from
   /xray/install/ccp4/ccp4-6.0.0/doc/library.doc lines 181-202: */

/* class info codes for int */
const DFNTI_MBO = 1; /* Motorola byte order 2's compl */
const DFNTI_IBO = 4; /* Intel byte order 2's compl */

/* class info codes for float */
const DFNTF_BEIEEE       = 1; /* big endian IEEE (canonical) */
const FNTF_VAX           = 2; /* Vax format */
const DFNTF_CONVEXNATIVE = 5; /* Convex native floats */
const DFNTF_LEIEEE       = 4; /* little-endian IEEE format */

struct CCP4MapHeader {
    int   columnNr;
    int   rowNr;
    int   sectionNr;
    int   mode;
    int   columnNrStart;
    int   rowNrStart;
    int   sectionNrStart;
    int   xIntervals;
    int   yIntervals;
    int   zIntervals;
    float cellA;
    float cellB;
    float cellC;
    float cellAlpha;
    float cellBeta;
    float cellGamma;
    int   mapCol;
    int   mapRow;
    int   mapSec;
    float minDensity;
    float maxDensity;
    float meanDensity;
    int   spaceGroup;
    int   symmetryBytes;
    int   skewFlag;
    float skewMatrix[][];    /* [9] */
    float skewTranslation[]; /* [3] */
    // int   dummy[15];
    blob  future;
    // char  mapSignature[4];
    string mapSignature;
    // unsigned char   machineStamp[4];
    int machineStamp;
    float rmsDeviation;
    int   labelNr;
    // char  labels[ LABEL_NUMBER ][ LABEL_LENGTH ];
    string labels[];
}

(*
        var iheader = unpack int[] ( map, 0, "i4x10,x4x6,i4x3" );
        var cell = unpack float[] ( map, 40, "f4x6" );
        var fheader = unpack float[] ( map, 19*4, "f4x3,X4x32,f4x1" );
        var signature = unpack string ( map, 52*4, "s4" );
        var nlabels = unpack int ( map, 55*4, "i4" );
        var labels = unpack string[] ( map, 56*4, "s80x10"  );

        var future = unpack int[] ( map, 37*4, "i4x" _ "%d" %% (52-38+1) );
        . "REMARK future words:", length(future);

// 25      LSKFLG          Flag for skew transformation, =0 none, =1 if foll
// 26-34   SKWMAT          Skew matrix S (in order S11, S12, S13, S21 etc) if
//                         LSKFLG .ne. 0.
// 35-37   SKWTRN          Skew translation t if LSKFLG .ne. 0.

        var skew_flag = unpack int ( map, 24*4, "i4" );
        var skew_matrix = unpack float[3][] ( map, 25*4, "f4x3" );
        var skew_transl = unpack float[] ( map, 34*4, "f4x3" );

        . "REMARK skew flag", skew_flag;
        for( var i = 0; i < length(skew_matrix); i ++ ) {
            < "REMARK skew matrix ";
            for( var j = 0; j < length(skew_matrix[i]); j ++ ) {
                < skew_matrix[i][j];
                < " ";
            }
            . "";
        }

        < "REMARK skew transl ";
        for( var i = 0; i < length(skew_transl); i++ ) {
            < skew_transl[i];
            < " ";
        }
        . "";

        var mstamp = unpack int ( map, 53*4, "i4" );
        . "REMARK machine stamp:", "0x%04X" %% mstamp;
    
        var sg_number = unpack int( map, 22*4, "i4" );

        if( signature != "MAP " ) {
            raise MAP_SIGNATURE_ERROR
                ( "file '" _ argv[argnr] _ "' is not a CCP4 map" );
        }

        print_cryst1( cell, sg_number => sg_number, Z => 1 );

        for( var i = 0;
             i < (nlabels < length(labels) ? nlabels : length(labels));
             i ++ ) {
            . "REMARK MAP LABEL[", i, "]", labels[i];
        }

        // var raster = unpack float[iheader[0]][iheader[1]][]
        //     ( map, 1024, "f4x" _ "%d" %% iheader[2] );

        var columns  = iheader[0];
        var rows     = iheader[1];
        var sections = iheader[2];

        var mode = iheader[3];
        . "REMARK MAP MODE", mode;

        var cstart = iheader[4];
        var rstart = iheader[5];
        var sstart = iheader[6];

        var xintervals = iheader[7];
        var yintervals = iheader[8];
        var zintervals = iheader[9];

        var mapCol = iheader[10]-1;
        var mapRow = iheader[11]-1;
        var mapSec = iheader[12]-1;

        var mapX = mapCol == 0 ? 0 : ( mapRow == 0 ? 1 : 2);
        var mapY = mapCol == 1 ? 0 : ( mapRow == 1 ? 1 : 2);
        var mapZ = mapCol == 2 ? 0 : ( mapRow == 2 ? 1 : 2);

        var crs_size = [ columns, rows, sections ];

        var xsize = crs_size[mapX];
        var ysize = crs_size[mapY];
        var zsize = crs_size[mapZ];

        var raster = new float[xsize][ysize][zsize];

        var row_format : string;
        var voxel_size : int;

        if( mode == 0 ) then
            // 0 = envelope stored as signed bytes (from
            //     -128 lowest to 127 highest)
            voxel_size = 1; /* bytes */
            row_format = "i%d" %% voxel_size  _ "x%d" %% columns;
        elsif( mode == 1 ) then
            // 1 = Image     stored as Integer*2
            voxel_size = 2; /* bytes */
            row_format = "i%d" %% voxel_size  _ "x%d" %% columns;
        elsif( mode == 2 ) then
            // 2 = Image     stored as Reals
            voxel_size = 4; /* bytes */
            row_format = "f%d" %% voxel_size  _ "x%d" %% columns;
        elsif( mode == 3 ) then
            // 3 = Transform stored as Complex Integer*2
            voxel_size = 4; /* bytes */
            row_format = "i2x%d" %% columns * 2;
        elsif( mode == 4 ) then
            // 4 = Transform stored as Complex Reals
            voxel_size = 8; /* bytes */
            row_format = "f4x%d" %% columns * 2;
        else
            // 5 == 0
            // and others -- not clear what it may be... S.G.
            raise MAP_MODE_ERROR( "unsupported mode=%d of CCP4 map" %% mode );
        endif

        . "REMARK xsize, ysize, zsize =", xintervals, yintervals, zintervals;
        . "REMARK cstart, rstart, sstart =", cstart, rstart, sstart;

        var symop_bytes = unpack int( map, 23*4, "i4" );

        . "REMARK symop bytes", symop_bytes;

        for var int s = 0 to sections - 1 {
            for var int r = 0 to rows - 1 {
                var row =
                    unpack float[]( map,
                                  1024 + symop_bytes +
                                  s * rows * columns * voxel_size + 
                                  r * columns * voxel_size,
                                  row_format );
                var crs = [ 0, r, s ];
                if( mode < 3 ) {
                    for crs[0] = 0 to columns - 1 {
                        raster[crs[mapX]][crs[mapY]][crs[mapZ]] = row[crs[0]];
                    }
                } else {
                    for crs[0] = 0 to columns - 1 {
                        // Take just the real part of the map:
                        raster[crs[mapX]][crs[mapY]][crs[mapZ]] = row[crs[0]*2];
                    }
                }
            }
        }
*)

end package CCP4Map
