package unsigned;

use * from std;

load "libraries/unsigned/libunsigned.so.0.01";

type ushort = {
    size = sizeof native "short";
    kind = integer;
    suffix = "UH";

    inline bytecode operator "+" ( i : ushort ) : ushort
        { /* do nothing */ };

    inline bytecode operator "+" ( i : ushort; j : ushort ) : ushort
        { LADD };
    inline bytecode operator "-" ( i : ushort; j : ushort ) : ushort
        { LSUB };
    inline bytecode operator "*" ( i : ushort; j : ushort ) : ushort
        { libunsigned:UHMUL };
    inline bytecode operator "/" ( i : ushort; j : ushort ) : ushort
        { libunsigned:UHDIV };
    inline bytecode operator "%" ( i : ushort; j : ushort ) : ushort
        { libunsigned:UHMOD };

    bytecode inline operator "<" ( x, y : ushort ) : bool
        { libunsigned:UHLTBOOL };
    bytecode inline operator ">" ( x, y : ushort ) : bool
        { libunsigned:UHGTBOOL };
    bytecode inline operator "<=" ( x, y : ushort ) : bool
        { libunsigned:UHLEBOOL };
    bytecode inline operator ">=" ( x, y : ushort ) : bool
        { libunsigned:UHGEBOOL };
    bytecode inline operator "==" ( x, y : ushort ) : bool
        { libunsigned:UHEQBOOL };
    bytecode inline operator "!=" ( x, y : ushort ) : bool
        { libunsigned:UHNEBOOL };

    bytecode inline operator "shl" ( x, y : ushort ) : ushort
	{ LSHL };
    bytecode inline operator "shr" ( x, y : ushort ) : ushort
	{ LSHR };
    bytecode inline operator "&" ( x, y : ushort ) : ushort
	{ LAND };
    bytecode inline operator "|" ( x, y : ushort ) : ushort
	{ LOR };
    bytecode inline operator "^" ( x, y : ushort ) : ushort
	{ LXOR };
    bytecode inline operator "~" ( x: ushort ) : ushort
	{ LNOT };

    inline bytecode operator "++" ( i : ushort ) : ushort
        { LINC };
    inline bytecode operator "--" ( i : ushort ) : ushort
        { LDEC };
    inline bytecode operator "incvar" ()
        { LINCVAR };
    inline bytecode operator "decvar" ()
        { LDECVAR };
    inline bytecode operator "." ( i : ushort )
        { libunsigned:UHPRINT };
    inline bytecode operator "<" ( i : ushort )
        { libunsigned:UHPRINT };

    inline bytecode operator "@ushort" ( i : char ) : ushort
        { libunsigned:UBEXTEND };

    inline bytecode operator "<<" ( f : file; i : ushort ) : file
    	{ libunsigned:UHFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : ushort
    	{ libunsigned:UHFILESCAN };

    inline bytecode operator "%%" ( format : string; x : ushort ) : string
        { libunsigned:UHSPRINTF };

    inline bytecode operator "%%" ( x : ushort ) : string
        { SLDC "%d" SWAP ISPRINTF };

    bytecode inline operator "jnz" ( x : ushort )
        { JNZ };
    bytecode inline operator "jz" ( x : ushort )
        { JZ };

    inline bytecode operator "ldc" () : ushort
        { libunsigned:UHLDCS };

    inline bytecode operator "loop" ( counter : addressof; range : ushort )
        { libunsigned:UHLOOP };

    inline bytecode operator "[]" ( a : array; i : ushort ) : addressof
        { libunsigned:UHINDEX };

    inline bytecode operator "[..]" ( a : array; lower, upper : ushort ) : array
        { libunsigned:UHSUBARRAY };

    inline bytecode operator "new[]" ( i : ushort ) : array
        { libunsigned:UHAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : ushort ) : blob
        { libunsigned:UHBLOB };

    inline bytecode operator "new[][]" ( i : ushort ) : array
        { libunsigned:UHMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "exceptionval" ( p : ref ) : ushort
        { ERRORCODE };

    inline bytecode operator "exceptionset" ( i : ushort ) : ushort
        { /* empty */ };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; ushort value )
        { libunsigned:UHPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; 
				     	  array of ushort value )
        { libunsigned:UHPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; 
				     	    array value )
        { libunsigned:UHPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : ushort
        { libunsigned:UHUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of ushort
        { libunsigned:UHUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                      	      string description ) : array
        { libunsigned:UHUNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( ushort i; int index ): byte
        { libunsigned:UHNthBYTE };

    /* The "last" operator provides the index of the last array "a"
    element is is necessary to compile an 'a[i:]' construct with the
    correct type of the upper limit (the type must be the same as of
    variable 'i': */

    inline bytecode operator "last"( a : array ): ushort
        { libunsigned:UHLENGTH DEC }
}

type uint = {
    size = sizeof native "int";
    kind = integer;
    suffix = "U";

    inline bytecode operator "+" ( i : uint ) : uint
        { /* do nothing */ };

    inline bytecode operator "+" ( i : uint; j : uint ) : uint
        { ADD };
    inline bytecode operator "-" ( i : uint; j : uint ) : uint
        { SUB };
    inline bytecode operator "*" ( i : uint; j : uint ) : uint
        { libunsigned:UMUL };
    inline bytecode operator "/" ( i : uint; j : uint ) : uint
        { libunsigned:UDIV };
    inline bytecode operator "%" ( i : uint; j : uint ) : uint
        { libunsigned:UMOD };

    bytecode inline operator "<" ( x, y : uint ) : bool
        { libunsigned:ULTBOOL };
    bytecode inline operator ">" ( x, y : uint ) : bool
        { libunsigned:UGTBOOL };
    bytecode inline operator "<=" ( x, y : uint ) : bool
        { libunsigned:ULEBOOL };
    bytecode inline operator ">=" ( x, y : uint ) : bool
        { libunsigned:UGEBOOL };
    bytecode inline operator "==" ( x, y : uint ) : bool
        { libunsigned:UEQBOOL };
    bytecode inline operator "!=" ( x, y : uint ) : bool
        { libunsigned:UNEBOOL };

    bytecode inline operator "shl" ( x, y : uint ) : uint
	{ SHL };
    bytecode inline operator "shr" ( x, y : uint ) : uint
	{ SHR };
    bytecode inline operator "&" ( x, y : uint ) : uint
	{ AND };
    bytecode inline operator "|" ( x, y : uint ) : uint
	{ OR };
    bytecode inline operator "^" ( x, y : uint ) : uint
	{ XOR };
    bytecode inline operator "~" ( x: uint ) : uint
	{ NOT };

    inline bytecode operator "++" ( i : uint ) : uint
        { INC };
    inline bytecode operator "--" ( i : uint ) : uint
        { DEC };
    inline bytecode operator "incvar" ()
        { INCVAR };
    inline bytecode operator "decvar" ()
        { DECVAR };
    inline bytecode operator "." ( i : uint )
        { libunsigned:UPRINT };
    inline bytecode operator "<" ( i : uint )
        { libunsigned:UPRINT };

    inline bytecode operator "@uint" ( i : char ) : uint
        { libunsigned:UBEXTEND libunsigned:UHEXTEND };

    inline bytecode operator "@uint" ( i : ushort ) : uint
        { libunsigned:UHEXTEND };

    inline bytecode operator "<<" ( f : file; i : uint ) : file
    	{ libunsigned:UFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : uint
    	{ libunsigned:UFILESCAN };

    inline bytecode operator "%%" ( format : string; x : uint ) : string
        { libunsigned:USPRINTF };

    inline bytecode operator "%%" ( x : uint ) : string
        { SLDC "%d" SWAP ISPRINTF };

    bytecode inline operator "jnz" ( x : uint )
        { JNZ };
    bytecode inline operator "jz" ( x : uint )
        { JZ };

    inline bytecode operator "ldc" () : uint
        { libunsigned:ULDCS };

    inline bytecode operator "loop" ( counter : addressof; range : uint )
        { libunsigned:ULOOP };

    inline bytecode operator "[]" ( a : array; i : uint ) : addressof
        { libunsigned:UINDEX };

    inline bytecode operator "[..]" ( a : array; lower, upper : uint ) : array
        { libunsigned:USUBARRAY };

    inline bytecode operator "new[]" ( i : uint ) : array
        { libunsigned:UAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : uint ) : blob
        { libunsigned:UBLOB };

    inline bytecode operator "new[][]" ( i : uint ) : array
        { libunsigned:UMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "exceptionval" ( p : ref ) : uint
        { ERRORCODE };

    inline bytecode operator "exceptionset" ( i : uint ) : uint
        { /* empty */ };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; uint value )
        { libunsigned:UPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; 
				     	  array of uint value )
        { libunsigned:UPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; 
				     	    array value )
        { libunsigned:UPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : uint
        { libunsigned:UUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of uint
        { libunsigned:UUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                      	      string description ) : array
        { libunsigned:UUNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( uint i; int index ): byte
        { libunsigned:UNthBYTE };

    /* The "last" operator provides the index of the last array "a"
    element is is necessary to compile an 'a[i:]' construct with the
    correct type of the upper limit (the type must be the same as of
    variable 'i': */

    inline bytecode operator "last"( a : array ): uint
        { libunsigned:ULENGTH DEC }
}

type ulong = {
    size = sizeof native "long";
    kind = integer;
    suffix = "UL";

    inline bytecode operator "+" ( i : ulong ) : ulong
        { /* do nothing */ };

    inline bytecode operator "+" ( i : ulong; j : ulong ) : ulong
        { LADD };
    inline bytecode operator "-" ( i : ulong; j : ulong ) : ulong
        { LSUB };
    inline bytecode operator "*" ( i : ulong; j : ulong ) : ulong
        { libunsigned:ULMUL };
    inline bytecode operator "/" ( i : ulong; j : ulong ) : ulong
        { libunsigned:ULDIV };
    inline bytecode operator "%" ( i : ulong; j : ulong ) : ulong
        { libunsigned:ULMOD };

    bytecode inline operator "<" ( x, y : ulong ) : bool
        { libunsigned:ULLTBOOL };
    bytecode inline operator ">" ( x, y : ulong ) : bool
        { libunsigned:ULGTBOOL };
    bytecode inline operator "<=" ( x, y : ulong ) : bool
        { libunsigned:ULLEBOOL };
    bytecode inline operator ">=" ( x, y : ulong ) : bool
        { libunsigned:ULGEBOOL };
    bytecode inline operator "==" ( x, y : ulong ) : bool
        { libunsigned:ULEQBOOL };
    bytecode inline operator "!=" ( x, y : ulong ) : bool
        { libunsigned:ULNEBOOL };

    bytecode inline operator "shl" ( x, y : ulong ) : ulong
	{ LSHL };
    bytecode inline operator "shr" ( x, y : ulong ) : ulong
	{ LSHR };
    bytecode inline operator "&" ( x, y : ulong ) : ulong
	{ LAND };
    bytecode inline operator "|" ( x, y : ulong ) : ulong
	{ LOR };
    bytecode inline operator "^" ( x, y : ulong ) : ulong
	{ LXOR };
    bytecode inline operator "~" ( x: ulong ) : ulong
	{ LNOT };

    inline bytecode operator "++" ( i : ulong ) : ulong
        { LINC };
    inline bytecode operator "--" ( i : ulong ) : ulong
        { LDEC };
    inline bytecode operator "incvar" ()
        { LINCVAR };
    inline bytecode operator "decvar" ()
        { LDECVAR };
    inline bytecode operator "." ( i : ulong )
        { libunsigned:ULPRINT };
    inline bytecode operator "<" ( i : ulong )
        { libunsigned:ULPRINT };

    inline bytecode operator "@ulong" ( i : char ) : ulong
        { libunsigned:UBEXTEND libunsigned:UHEXTEND
          libunsigned:UEXTEND };

    inline bytecode operator "@ulong" ( i : ushort ) : ulong
        { libunsigned:UHEXTEND libunsigned:UEXTEND };

    inline bytecode operator "@ulong" ( i : uint ) : ulong
        { libunsigned:UEXTEND };

    inline bytecode operator "<<" ( f : file; i : ulong ) : file
    	{ libunsigned:ULFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : ulong
    	{ libunsigned:ULFILESCAN };

    inline bytecode operator "%%" ( format : string; x : ulong ) : string
        { libunsigned:ULSPRINTF };

    inline bytecode operator "%%" ( x : ulong ) : string
        { SLDC "%d" SWAP ISPRINTF };

    bytecode inline operator "jnz" ( x : ulong )
        { JNZ };
    bytecode inline operator "jz" ( x : ulong )
        { JZ };

    inline bytecode operator "ldc" () : ulong
        { libunsigned:ULLDCS };

    inline bytecode operator "loop" ( counter : addressof; range : ulong )
        { libunsigned:ULLOOP };

    inline bytecode operator "[]" ( a : array; i : ulong ) : addressof
        { libunsigned:ULINDEX };

    inline bytecode operator "[..]" ( a : array; lower, upper : ulong ) : array
        { libunsigned:ULSUBARRAY };

    inline bytecode operator "new[]" ( i : ulong ) : array
        { libunsigned:ULAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : ulong ) : blob
        { libunsigned:ULBLOB };

    inline bytecode operator "new[][]" ( i : ulong ) : array
        { libunsigned:ULMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "exceptionval" ( p : ref ) : ulong
        { ERRORCODE };

    inline bytecode operator "exceptionset" ( i : ulong ) : ulong
        { /* empty */ };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; ulong value )
        { libunsigned:ULPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; 
				     	  array of ulong value )
        { libunsigned:ULPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; 
				     	    array value )
        { libunsigned:ULPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : ulong
        { libunsigned:ULUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of ulong
        { libunsigned:ULUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                      	      string description ) : array
        { libunsigned:ULUNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( ulong i; int index ): byte
        { libunsigned:ULNthBYTE };

    /* The "last" operator provides the index of the last array "a"
    element is is necessary to compile an 'a[i:]' construct with the
    correct type of the upper limit (the type must be the same as of
    variable 'i': */

    inline bytecode operator "last"( a : array ): ulong
        { libunsigned:ULLENGTH DEC }
}

type ullong = {
    size = sizeof native "llong";
    kind = integer;
    suffix = "ULL";

    inline bytecode operator "+" ( i : ullong ) : ullong
        { /* do nothing */ };

    inline bytecode operator "+" ( i : ullong; j : ullong ) : ullong
        { LLADD };
    inline bytecode operator "-" ( i : ullong; j : ullong ) : ullong
        { LLSUB };
    inline bytecode operator "*" ( i : ullong; j : ullong ) : ullong
        { libunsigned:ULLMUL };
    inline bytecode operator "/" ( i : ullong; j : ullong ) : ullong
        { libunsigned:ULLDIV };
    inline bytecode operator "%" ( i : ullong; j : ullong ) : ullong
        { libunsigned:ULLMOD };

    bytecode inline operator "<" ( x, y : ullong ) : bool
        { libunsigned:ULLLTBOOL };
    bytecode inline operator ">" ( x, y : ullong ) : bool
        { libunsigned:ULLGTBOOL };
    bytecode inline operator "<=" ( x, y : ullong ) : bool
        { libunsigned:ULLLEBOOL };
    bytecode inline operator ">=" ( x, y : ullong ) : bool
        { libunsigned:ULLGEBOOL };
    bytecode inline operator "==" ( x, y : ullong ) : bool
        { libunsigned:ULLEQBOOL };
    bytecode inline operator "!=" ( x, y : ullong ) : bool
        { libunsigned:ULLNEBOOL };

    bytecode inline operator "shl" ( x, y : ullong ) : ullong
	{ LLSHL };
    bytecode inline operator "shr" ( x, y : ullong ) : ullong
	{ LLSHR };
    bytecode inline operator "&" ( x, y : ullong ) : ullong
	{ LLAND };
    bytecode inline operator "|" ( x, y : ullong ) : ullong
	{ LLOR };
    bytecode inline operator "^" ( x, y : ullong ) : ullong
	{ LLXOR };
    bytecode inline operator "~" ( x: ullong ) : ullong
	{ LLNOT };

    inline bytecode operator "++" ( i : ullong ) : ullong
        { LLINC };
    inline bytecode operator "--" ( i : ullong ) : ullong
        { LLDEC };
    inline bytecode operator "incvar" ()
        { LLINCVAR };
    inline bytecode operator "decvar" ()
        { LLDECVAR };
    inline bytecode operator "." ( i : ullong )
        { libunsigned:ULLPRINT };
    inline bytecode operator "<" ( i : ullong )
        { libunsigned:ULLPRINT };

    inline bytecode operator "@ullong" ( i : char ) : ullong
        { libunsigned:UBEXTEND libunsigned:UHEXTEND
          libunsigned:UEXTEND libunsigned:ULEXTEND };

    inline bytecode operator "@ullong" ( i : ushort ) : ullong
        { libunsigned:UHEXTEND
          libunsigned:UEXTEND libunsigned:ULEXTEND };

    inline bytecode operator "@ullong" ( i : uint ) : ullong
        { libunsigned:UEXTEND libunsigned:ULEXTEND };

    inline bytecode operator "@ullong" ( i : ulong ) : ullong
        { libunsigned:ULEXTEND };

    inline bytecode operator "<<" ( f : file; i : ullong ) : file
    	{ libunsigned:ULLFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : ullong
    	{ libunsigned:ULLFILESCAN };

    inline bytecode operator "%%" ( format : string; x : ullong ) : string
        { libunsigned:ULLSPRINTF };

    inline bytecode operator "%%" ( x : ullong ) : string
        { SLDC "%d" SWAP libunsigned:ULLSPRINTF };

    bytecode inline operator "jnz" ( x : ullong )
        { JNZ };
    bytecode inline operator "jz" ( x : ullong )
        { JZ };

    inline bytecode operator "ldc" () : ullong
        { libunsigned:ULLLDCS };

    inline bytecode operator "loop" ( counter : addressof; range : ullong )
        { libunsigned:ULLLOOP };

    inline bytecode operator "[]" ( a : array; i : ullong ) : addressof
        { libunsigned:ULLINDEX };

    inline bytecode operator "[..]" ( a : array; lower, upper : ullong ) : array
        { libunsigned:ULLSUBARRAY };

    inline bytecode operator "new[]" ( i : ullong ) : array
        { libunsigned:ULLAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : ullong ) : blob
        { libunsigned:ULLBLOB };

    inline bytecode operator "new[][]" ( i : ullong ) : array
        { libunsigned:ULLMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "exceptionval" ( p : ref ) : ullong
        { ERRORCODE };

    inline bytecode operator "exceptionset" ( i : ullong ) : ullong
        { /* empty */ };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; ullong value )
        { libunsigned:ULLPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; 
				     	  array of ullong value )
        { libunsigned:ULLPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; 
				     	    array value )
        { libunsigned:ULLPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : ullong
        { libunsigned:ULLUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of ullong
        { libunsigned:ULLUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                      	      string description ) : array
        { libunsigned:ULLUNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( ullong i; int index ): byte
        { libunsigned:ULLNthBYTE };

    /* The "last" operator provides the index of the last array "a"
    element is is necessary to compile an 'a[i:]' construct with the
    correct type of the upper limit (the type must be the same as of
    variable 'i': */

    inline bytecode operator "last"( a : array ): ullong
        { libunsigned:ULLLENGTH DEC }
}

end package unsigned;
