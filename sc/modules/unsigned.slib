package unsigned;

use * from std;

load "libraries/unsigned/libunsigned.so.0.01";

type uint = {
    size = sizeof native "int";
    kind = integer;
    suffix = "U";

    inline bytecode operator "+" ( i : uint ) : uint
        { /* do nothing */ };

    inline bytecode operator "+" ( i : uint; j : uint ) : uint
        { ADD };
    inline bytecode operator "-" ( i : uint; j : uint ) : uint
        { SUB };
    inline bytecode operator "*" ( i : uint; j : uint ) : uint
        { libunsigned:UMUL };
    inline bytecode operator "/" ( i : uint; j : uint ) : uint
        { libunsigned:UDIV };
    inline bytecode operator "%" ( i : uint; j : uint ) : uint
        { libunsigned:UMOD };

    bytecode inline operator "<" ( x, y : uint ) : bool
        { libunsigned:ULTBOOL };
    bytecode inline operator ">" ( x, y : uint ) : bool
        { libunsigned:UGTBOOL };
    bytecode inline operator "<=" ( x, y : uint ) : bool
        { libunsigned:ULEBOOL };
    bytecode inline operator ">=" ( x, y : uint ) : bool
        { libunsigned:UGEBOOL };
    bytecode inline operator "==" ( x, y : uint ) : bool
        { libunsigned:UEQBOOL };
    bytecode inline operator "!=" ( x, y : uint ) : bool
        { libunsigned:UNEBOOL };

    bytecode inline operator "shl" ( x, y : uint ) : uint
	{ SHL };
    bytecode inline operator "shr" ( x, y : uint ) : uint
	{ SHR };
    bytecode inline operator "&" ( x, y : uint ) : uint
	{ AND };
    bytecode inline operator "|" ( x, y : uint ) : uint
	{ OR };
    bytecode inline operator "^" ( x, y : uint ) : uint
	{ XOR };
    bytecode inline operator "~" ( x: uint ) : uint
	{ NOT };

    inline bytecode operator "++" ( i : uint ) : uint
        { INC };
    inline bytecode operator "--" ( i : uint ) : uint
        { DEC };
    inline bytecode operator "incvar" ()
        { INCVAR };
    inline bytecode operator "decvar" ()
        { DECVAR };
    inline bytecode operator "." ( i : uint )
        { libunsigned:UPRINT };
    inline bytecode operator "<" ( i : uint )
        { libunsigned:UPRINT };

    inline bytecode operator "@uint" ( i : byte ) : uint
        { BEXTEND HEXTEND };

    inline bytecode operator "@uint" ( i : short ) : uint
        { HEXTEND };

    inline bytecode operator "<<" ( f : file; i : uint ) : file
    	{ libunsigned:UFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : uint
    	{ libunsigned:UFILESCAN };

    inline bytecode operator "%%" ( format : string; x : uint ) : string
        { libunsigned:USPRINTF };

    inline bytecode operator "%%" ( x : uint ) : string
        { SLDC "%d" SWAP ISPRINTF };

    bytecode inline operator "jnz" ( x : uint )
        { JNZ };
    bytecode inline operator "jz" ( x : uint )
        { JZ };

    inline bytecode operator "ldc" () : uint
        { libunsigned:ULDCS };

    inline bytecode operator "loop" ( counter : addressof; range : uint )
        { libunsigned:ULOOP };

    inline bytecode operator "[]" ( a : array; i : uint ) : addressof
        { libunsigned:UINDEX };

    inline bytecode operator "[..]" ( a : array; lower, upper : uint ) : array
        { libunsigned:USUBARRAY };

    inline bytecode operator "new[]" ( i : uint ) : array
        { libunsigned:UAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : uint ) : blob
        { libunsigned:UBLOB };

    inline bytecode operator "new[][]" ( i : uint ) : array
        { libunsigned:UMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "exceptionval" ( p : ref ) : uint
        { ERRORCODE };

    inline bytecode operator "exceptionset" ( i : uint ) : uint
        { /* empty */ };

    inline bytecode operator "pack"( blob b; uint offset;
                                     string description; uint value )
        { libunsigned:UPACK };

    inline bytecode operator "packarray"( blob b; uint offset;
                                     	  string description; 
				     	  array of uint value )
        { libunsigned:UPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; uint offset;
                                     	    string description; 
				     	    array value )
        { libunsigned:UPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; uint offset;
                                       string description ) : uint
        { libunsigned:UUNPACK };

    inline bytecode operator "unpackarray"( blob b; uint offset;
                                       	    string description ) : array of uint
        { libunsigned:UUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; uint offset;
                                      	      string description ) : array
        { libunsigned:UUNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( uint i; uint index ): byte
        { libunsigned:UNthBYTE };

    /* The "last" operator provides the index of the last array "a"
    element is is necessary to compile an 'a[i:]' construct with the
    correct type of the upper limit (the type must be the same as of
    variable 'i': */

    inline bytecode operator "last"( a : array ): uint
        { libunsigned:ULENGTH DEC }
}

type ulong = {
    size = sizeof native "long";
    kind = integer;
    suffix = "UL";

    inline bytecode operator "+" ( i : ulong ) : ulong
        { /* do nothing */ };

    inline bytecode operator "+" ( i : ulong; j : ulong ) : ulong
        { LADD };
    inline bytecode operator "-" ( i : ulong; j : ulong ) : ulong
        { LSUB };
    inline bytecode operator "*" ( i : ulong; j : ulong ) : ulong
        { libunsigned:ULMUL };
    inline bytecode operator "/" ( i : ulong; j : ulong ) : ulong
        { libunsigned:ULDIV };
    inline bytecode operator "%" ( i : ulong; j : ulong ) : ulong
        { libunsigned:ULMOD };

    bytecode inline operator "<" ( x, y : ulong ) : bool
        { libunsigned:ULLTBOOL };
    bytecode inline operator ">" ( x, y : ulong ) : bool
        { libunsigned:ULGTBOOL };
    bytecode inline operator "<=" ( x, y : ulong ) : bool
        { libunsigned:ULLEBOOL };
    bytecode inline operator ">=" ( x, y : ulong ) : bool
        { libunsigned:ULGEBOOL };
    bytecode inline operator "==" ( x, y : ulong ) : bool
        { libunsigned:ULEQBOOL };
    bytecode inline operator "!=" ( x, y : ulong ) : bool
        { libunsigned:ULNEBOOL };

    bytecode inline operator "shl" ( x, y : ulong ) : ulong
	{ LSHL };
    bytecode inline operator "shr" ( x, y : ulong ) : ulong
	{ LSHR };
    bytecode inline operator "&" ( x, y : ulong ) : ulong
	{ LAND };
    bytecode inline operator "|" ( x, y : ulong ) : ulong
	{ LOR };
    bytecode inline operator "^" ( x, y : ulong ) : ulong
	{ LXOR };
    bytecode inline operator "~" ( x: ulong ) : ulong
	{ LNOT };

    inline bytecode operator "++" ( i : ulong ) : ulong
        { LINC };
    inline bytecode operator "--" ( i : ulong ) : ulong
        { LDEC };
    inline bytecode operator "incvar" ()
        { LINCVAR };
    inline bytecode operator "decvar" ()
        { LDECVAR };
    inline bytecode operator "." ( i : ulong )
        { libunsigned:ULPRINT };
    inline bytecode operator "<" ( i : ulong )
        { libunsigned:ULPRINT };

    inline bytecode operator "@ulong" ( i : byte ) : ulong
        { BEXTEND HEXTEND };

    inline bytecode operator "@ulong" ( i : short ) : ulong
        { HEXTEND };

    inline bytecode operator "<<" ( f : file; i : ulong ) : file
    	{ libunsigned:ULFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : ulong
    	{ libunsigned:ULFILESCAN };

    inline bytecode operator "%%" ( format : string; x : ulong ) : string
        { libunsigned:ULSPRINTF };

    inline bytecode operator "%%" ( x : ulong ) : string
        { SLDC "%d" SWAP ISPRINTF };

    bytecode inline operator "jnz" ( x : ulong )
        { JNZ };
    bytecode inline operator "jz" ( x : ulong )
        { JZ };

    inline bytecode operator "ldc" () : ulong
        { libunsigned:ULLDCS };

    inline bytecode operator "loop" ( counter : addressof; range : ulong )
        { libunsigned:ULLOOP };

    inline bytecode operator "[]" ( a : array; i : ulong ) : addressof
        { libunsigned:ULINDEX };

    inline bytecode operator "[..]" ( a : array; lower, upper : ulong ) : array
        { libunsigned:ULSUBARRAY };

    inline bytecode operator "new[]" ( i : ulong ) : array
        { libunsigned:ULAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : ulong ) : blob
        { libunsigned:ULBLOB };

    inline bytecode operator "new[][]" ( i : ulong ) : array
        { libunsigned:ULMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "exceptionval" ( p : ref ) : ulong
        { ERRORCODE };

    inline bytecode operator "exceptionset" ( i : ulong ) : ulong
        { /* empty */ };

    inline bytecode operator "pack"( blob b; ulong offset;
                                     string description; ulong value )
        { libunsigned:ULPACK };

    inline bytecode operator "packarray"( blob b; ulong offset;
                                     	  string description; 
				     	  array of ulong value )
        { libunsigned:ULPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; ulong offset;
                                     	    string description; 
				     	    array value )
        { libunsigned:ULPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; ulong offset;
                                       string description ) : ulong
        { libunsigned:ULUNPACK };

    inline bytecode operator "unpackarray"( blob b; ulong offset;
                                       	    string description ) : array of ulong
        { libunsigned:ULUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; ulong offset;
                                      	      string description ) : array
        { libunsigned:ULUNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( ulong i; ulong index ): byte
        { libunsigned:ULNthBYTE };

    /* The "last" operator provides the index of the last array "a"
    element is is necessary to compile an 'a[i:]' construct with the
    correct type of the upper limit (the type must be the same as of
    variable 'i': */

    inline bytecode operator "last"( a : array ): ulong
        { libunsigned:ULLENGTH DEC }
}

end package unsigned;
