
package std1

#
# Definition of standard types for the SL language.
#

type string;
type int;

type bool = {
    size = 1;
    suffix = b;
    kind = integer;

    bytecode inline operator "!" ( x : bool ) : bool
	{ BBOOLNOT };

    bytecode inline operator "==" ( x, y : bool ) : bool
	{ BEQ };

    bytecode inline operator "!=" ( x, y : bool ) : bool
	{ BNE };

    inline bytecode operator "ldc" () : bool
        { BLDCS };

    bytecode inline operator "jnz" ( x : bool )
        { BJNZ };

    bytecode inline operator "jz" ( x : bool )
        { BJZ };

    inline bytecode operator "assert" ( x : bool )
    {
        ASSERT %%lineno %%file %%line
    }
}

readonly false = 0b;
readonly true = 1b;

type int;

type char = {
    size = 1;
    suffix = c;
    kind = string;

    inline bytecode operator "ldc" () : char
        { CLDCS };

    bytecode inline operator "==" ( x, y : char ) : bool
	{ BEQ };

    bytecode inline operator "!=" ( x, y : char ) : bool
	{ BNE };

    bytecode inline operator "shl" ( x, y : char ) : char
	{ BSHL };

    bytecode inline operator "shr" ( x, y : char ) : char
	{ BSHR };

    bytecode inline operator "&" ( x, y : char ) : char
	{ BAND };

    bytecode inline operator "|" ( x, y : char ) : char
	{ BOR };

    bytecode inline operator "^" ( x, y : char ) : char
	{ BXOR };

    inline bytecode operator "<" ( c : char )
        { CPRINT };

    inline bytecode operator "." ( c : char )
        { CPRINT };

    inline bytecode operator "[]" ( a : array; i : char ) : addressof
        { BINDEX };

    inline bytecode operator "%%" ( format : string; x : char ) : string
        { BSPRINTF };

    inline bytecode operator "%%" ( x : char ) : string
        { SLDC "%c" SWAP BSPRINTF };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; char value )
        { BPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; char[] value )
        { BPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; array value )
        { BPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : char
        { BUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of char
        { BUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                       	      string description ) : array
        { BUNPACKMDARRAY %%level };
}

type ref = null {
    kind = ref;
    reference;
    bytecode inline operator "==" ( x, y : ref ) : bool
	{ PEQBOOL };
    bytecode inline operator "!=" ( x, y : ref ) : bool
	{ PNEBOOL };
    bytecode inline operator "!" ( x : ref ) : bool
	{ PZBOOL };
};

type blob = null {
    kind = ref;
    reference;
    bytecode inline operator "==" ( x, y : ref ) : bool
	{ PEQBOOL };
    bytecode inline operator "!=" ( x, y : ref ) : bool
	{ PNEBOOL };
    bytecode inline operator "!" ( x : ref ) : bool
	{ PZBOOL };
};

type array = {
    kind = ref;
    reference;
    bytecode inline operator "==" ( x, y : array ) : bool
	{ PEQBOOL };
    bytecode inline operator "!=" ( x, y : array ) : bool
	{ PNEBOOL };
    bytecode inline operator "!" ( x : array ) : bool
	{ PZBOOL };
    bytecode inline operator "next" ( x : array )
	{ ADVANCE };
};

type struct = {
        kind = ref;
        reference;
	//size = sizeof native "void*";
        (*
	bytecode inline operator "==" ( x, y : ref ) : bool
		{ PEQBOOL };
	bytecode inline operator "!=" ( x, y : ref ) : bool
		{ PNEBOOL };
	bytecode inline operator "!" ( x : ref ) : bool
		{ PZBOOL };
        *)
}

(*
type procedure = {
	kind = ref;
	reference;
	size = sizeof native "void*";
	bytecode inline operator "==" ( x, y : ref ) : bool
		{ PEQBOOL };
	bytecode inline operator "!=" ( x, y : ref ) : bool
		{ PNEBOOL };
	bytecode inline operator "!" ( x : ref ) : bool
		{ PZBOOL };
}

type file = ?{
    suffix = "file"; // just to avoid empty suffix conflicts with enum types...
    reference;

    bytecode inline operator "==" ( x, y : ref ) : bool
	{ PEQBOOL };
    bytecode inline operator "!=" ( x, y : ref ) : bool
	{ PNEBOOL };
    bytecode inline operator "!" ( x : ref ) : bool
	{ PZBOOL };
}

type byte = {
    size = sizeof native "char";
    kind = integer;
    suffix = "B";

    inline bytecode operator "+" ( i : byte ) : byte
        { /* do nothing */ };
    inline bytecode operator "-" ( i : byte ) : byte
        { BNEG };

    inline bytecode operator "+" ( i : byte; j : byte ) : byte
        { BADD };
    inline bytecode operator "-" ( i : byte; j : byte ) : byte
        { BSUB };
    inline bytecode operator "*" ( i : byte; j : byte ) : byte
        { BMUL };
    inline bytecode operator "/" ( i : byte; j : byte ) : byte
        { BDIV };
    inline bytecode operator "%" ( i : byte; j : byte ) : byte
        { BMOD };

    bytecode inline operator "<" ( x, y : byte ) : bool
        { BLTBOOL };
    bytecode inline operator ">" ( x, y : byte ) : bool
        { BGTBOOL };
    bytecode inline operator "<=" ( x, y : byte ) : bool
        { BLEBOOL };
    bytecode inline operator ">=" ( x, y : byte ) : bool
        { BGEBOOL };
    bytecode inline operator "==" ( x, y : byte ) : bool
        { BEQBOOL };
    bytecode inline operator "!=" ( x, y : byte ) : bool
        { BNEBOOL };

    bytecode inline operator "shl" ( x, y : byte ) : byte
	{ BSHL };
    bytecode inline operator "shr" ( x, y : byte ) : byte
	{ BSHR };
    bytecode inline operator "&" ( x, y : byte ) : byte
	{ BAND };
    bytecode inline operator "|" ( x, y : byte ) : byte
	{ BOR };
    bytecode inline operator "^" ( x, y : byte ) : byte
	{ BXOR };

    inline bytecode operator "++" ( i : byte ) : byte
        { BINC };
    inline bytecode operator "--" ( i : byte ) : byte
        { BDEC };
    inline bytecode operator "incvar" ()
        { BINCVAR };
    inline bytecode operator "decvar" ()
        { BDECVAR };
    inline bytecode operator "." ( i : byte )
        { BPRINT };
    inline bytecode operator "<" ( i : byte )
        { BPRINT };

    inline bytecode operator "@byte" ( i : byte ) : byte {};

    bytecode inline operator "jnz" ( x : byte )
        { BJNZ };
    bytecode inline operator "jz" ( x : byte )
        { BJZ };

    inline bytecode operator "ldc" () : byte
        { BLDCS };

    inline bytecode operator "loop" ( counter : addressof; range : byte )
        { BLOOP };

    inline bytecode operator "[]" ( a : array; i : byte ) : addressof
        { BINDEX };

    inline bytecode operator "new[]" ( i : byte ) : array
        { BAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : byte ) : blob
        { BBLOB };

    inline bytecode operator "new[][]" ( i : byte ) : array
        { BMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "%%" ( format : string; x : byte ) : string
        { BSPRINTF };

    inline bytecode operator "%%" ( x : byte ) : string
        { SLDC "%hhd" SWAP BSPRINTF };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; byte value )
        { BPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; byte[] value )
        { BPACKARRAY };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : byte
        { BUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of byte
        { BUNPACKARRAY };

    inline bytecode operator "nth-byte"( byte i; int index ): byte
        { BNthBYTE };
}

type short = {
    size = sizeof native "short";
    kind = integer;
    suffix = "S";

    inline bytecode operator "+" ( i : short ) : short
        { /* do nothing */ };
    inline bytecode operator "-" ( i : short ) : short
        { HNEG };

    inline bytecode operator "+" ( i : short; j : short ) : short
        { HADD };
    inline bytecode operator "-" ( i : short; j : short ) : short
        { HSUB };
    inline bytecode operator "*" ( i : short; j : short ) : short
        { HMUL };
    inline bytecode operator "/" ( i : short; j : short ) : short
        { HDIV };
    inline bytecode operator "%" ( i : short; j : short ) : short
        { HMOD };

    bytecode inline operator "<" ( x, y : short ) : bool
        { HLTBOOL };
    bytecode inline operator ">" ( x, y : short ) : bool
        { HGTBOOL };
    bytecode inline operator "<=" ( x, y : short ) : bool
        { HLEBOOL };
    bytecode inline operator ">=" ( x, y : short ) : bool
        { HGEBOOL };
    bytecode inline operator "==" ( x, y : short ) : bool
        { HEQBOOL };
    bytecode inline operator "!=" ( x, y : short ) : bool
        { HNEBOOL };

    bytecode inline operator "shl" ( x, y : short ) : short
	{ HSHL };
    bytecode inline operator "shr" ( x, y : short ) : short
	{ HSHR };
    bytecode inline operator "&" ( x, y : short ) : short
	{ HAND };
    bytecode inline operator "|" ( x, y : short ) : short
	{ HOR };
    bytecode inline operator "^" ( x, y : short ) : short
	{ HXOR };

    inline bytecode operator "++" ( i : short ) : short
        { HINC };
    inline bytecode operator "--" ( i : short ) : short
        { HDEC };
    inline bytecode operator "incvar" ()
        { HINCVAR };
    inline bytecode operator "decvar" ()
        { HDECVAR };

    inline bytecode operator "." ( i : short )
        { HPRINT };
    inline bytecode operator "<" ( i : short )
        { HPRINT };

    inline bytecode operator "%%" ( format : string; x : short ) : string
        { HSPRINTF };

    inline bytecode operator "%%" ( x : short ) : string
        { SLDC "%hd" SWAP HSPRINTF };

    inline bytecode operator "ldc" () : short
        { HLDCS };

    inline bytecode operator "loop" ( counter : addressof; range : short )
        { HLOOP };

    inline bytecode operator "[]" ( a : array; i : short ) : addressof
        { HINDEX };

    inline bytecode operator "new[]" ( i : short ) : array
        { HAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : short ) : blob
        { HBLOB };

    inline bytecode operator "new[][]" ( i : short ) : array
        { HMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; short value )
        { HPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; 
				     	  array of short value )
        { HPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; 
				     	    array value )
        { HPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : short
        { HUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : 
					    array of short
        { HUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                      	      string description ) : array
        { HUNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( short i; int index ): byte
        { HNthBYTE };
}

type int = {
    size = sizeof native "int";
    kind = integer;

    inline bytecode operator "+" ( i : int ) : int
        { /* do nothing */ };
    inline bytecode operator "-" ( i : int ) : int
        { NEG };

    inline bytecode operator "+" ( i : int; j : int ) : int
        { ADD };
    inline bytecode operator "-" ( i : int; j : int ) : int
        { SUB };
    inline bytecode operator "*" ( i : int; j : int ) : int
        { MUL };
    inline bytecode operator "/" ( i : int; j : int ) : int
        { DIV };
    inline bytecode operator "%" ( i : int; j : int ) : int
        { MOD };

    bytecode inline operator "<" ( x, y : int ) : bool
        { LTBOOL };
    bytecode inline operator ">" ( x, y : int ) : bool
        { GTBOOL };
    bytecode inline operator "<=" ( x, y : int ) : bool
        { LEBOOL };
    bytecode inline operator ">=" ( x, y : int ) : bool
        { GEBOOL };
    bytecode inline operator "==" ( x, y : int ) : bool
        { EQBOOL };
    bytecode inline operator "!=" ( x, y : int ) : bool
        { NEBOOL };

    bytecode inline operator "shl" ( x, y : int ) : int
	{ SHL };
    bytecode inline operator "shr" ( x, y : int ) : int
	{ SHR };
    bytecode inline operator "&" ( x, y : int ) : int
	{ AND };
    bytecode inline operator "|" ( x, y : int ) : int
	{ OR };
    bytecode inline operator "^" ( x, y : int ) : int
	{ XOR };

    inline bytecode operator "++" ( i : int ) : int
        { INC };
    inline bytecode operator "--" ( i : int ) : int
        { DEC };
    inline bytecode operator "incvar" ()
        { INCVAR };
    inline bytecode operator "decvar" ()
        { DECVAR };
    inline bytecode operator "." ( i : int )
        { IPRINT };
    inline bytecode operator "<" ( i : int )
        { IPRINT };

    inline bytecode operator "@int" ( i : byte ) : int
        { BEXTEND HEXTEND };

    inline bytecode operator "@int" ( i : short ) : int
        { HEXTEND };

    inline bytecode operator "<<" ( f : file; i : int ) : file
    	{ FILEPRINT };

    inline bytecode operator ">>" ( f : file ) : int
    	{ FILESCAN };

    inline bytecode operator "%%" ( format : string; x : int ) : string
        { ISPRINTF };

    inline bytecode operator "%%" ( x : int ) : string
        { SLDC "%d" SWAP ISPRINTF };

    bytecode inline operator "jnz" ( x : int )
        { JNZ };
    bytecode inline operator "jz" ( x : int )
        { JZ };

    inline bytecode operator "ldc" () : int
        { LDCS };

    inline bytecode operator "loop" ( counter : addressof; range : int )
        { LOOP };

    inline bytecode operator "[]" ( a : array; i : int ) : addressof
        { INDEX };

    inline bytecode operator "[..]" ( a : array; lower, upper : int ) : array
        { SUBARRAY };

    inline bytecode operator "new[]" ( i : int ) : array
        { AALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : int ) : blob
        { BLOB };

    inline bytecode operator "new[][]" ( i : int ) : array
        { MDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "exceptionval" ( p : ref ) : int
        { ERRORCODE };

    inline bytecode operator "exceptionset" ( i : int ) : int
        { /* empty */ };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; int value )
        { PACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; 
				     	  array of int value )
        { PACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; 
				     	    array value )
        { PACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : int
        { UNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of int
        { UNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                      	      string description ) : array
        { UNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( int i; int index ): byte
        { NthBYTE };

    /* The "last" operator provides teh index of the last array "a"
    element is is necessary to compile an 'a[i:]' construct with the
    correct type of the upper limit (the type must be the same as of
    variable 'i': */

    inline bytecode operator "last"( a : array ): int
        { LENGTH DEC }
}
*)

end package std1;
