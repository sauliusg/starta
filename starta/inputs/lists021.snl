#--*- Java -*--
# Starta compiler tests.
#
# Check functional primitives: map()
#

use std;

type list of T = ? : ref {
    next : list of T;
    value : T;

    operator "+" ( l1, l2 : list of T ) : list of T
    {
	if( l1 && l2 ) {
	    var r = l1[];
	    var q = r;
	    var p = l1.next;
	    while( p != null ) {
		q.next = p[];
		q = q.next;
		p = p.next;
	    }
	    q.next = l2;
	    return r
	} else {
	    if( l1 ) {
		return l1
	    } else {
		return l2
	    }
	}
    }; // operator "+"

    // inline bytecode operator "*" ( l : list of T ) : T
    // { LDC const((list of T).value.offset) }

    inline bytecode operator "next"( l : list of T )
    { NEXT const((list of T).next.offset) const((list of T).value.offset) }

} // type "list of T"

type L = list of int;

procedure cat( l1, l2 : list of int ) : list of int
{
    l1.next = l2;
    return l1
}

var l = (10, 11, 21, 32);

. l.value;
