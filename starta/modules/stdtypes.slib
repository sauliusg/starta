#
# Definition of standard types for the SL language.
#

type string;
type int;

type bool = {
    size = 1;
    suffix = b;
    kind = integer;

    bytecode inline operator "!" ( x : bool ) : bool
	{ BBOOLNOT };

    bytecode inline operator "==" ( x, y : bool ) : bool
	{ BEQ };

    bytecode inline operator "!=" ( x, y : bool ) : bool
	{ BNE };

    inline bytecode operator "ldc" () : bool
        { BLDCS };

    bytecode inline operator "jnz" ( x : bool )
        { BJNZ };

    bytecode inline operator "jz" ( x : bool )
        { BJZ };

    inline bytecode operator "<" ( x : bool )
        { BJZ +7 SLDC "T" SPRINT JMP +5 SLDC "F" SPRINT };

    inline bytecode operator "." ( x : bool )
        { BJZ +7 SLDC "T" SPRINT JMP +5 SLDC "F" SPRINT };

    inline bytecode operator "assert" ( x : bool )
    {
        ASSERT %%lineno %%file %%line
    }
}

readonly false = 0b;
readonly true = 1b;

type int;

type char = {
    size = 1;
    suffix = c;
    kind = string;

    inline bytecode operator "ldc" () : char
        { CLDCS };

    bytecode inline operator "==" ( x, y : char ) : bool
	{ BEQ };

    bytecode inline operator "!=" ( x, y : char ) : bool
	{ BNE };

    bytecode inline operator "shl" ( x, y : char ) : char
	{ BSHL };

    bytecode inline operator "shr" ( x, y : char ) : char
	{ BSHR };

    bytecode inline operator "&" ( x, y : char ) : char
	{ BAND };

    bytecode inline operator "|" ( x, y : char ) : char
	{ BOR };

    bytecode inline operator "^" ( x, y : char ) : char
	{ BXOR };

    inline bytecode operator "<" ( c : char )
        { CPRINT };

    inline bytecode operator "." ( c : char )
        { CPRINT };

    inline bytecode operator "[]" ( a : array; i : char ) : addressof
        { BINDEX };

    inline bytecode operator "%%" ( format : string; x : char ) : string
        { BSPRINTF };

    inline bytecode operator "%%" ( x : char ) : string
        { SLDC "%c" SWAP BSPRINTF };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; char value )
        { BPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; char[] value )
        { BPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; array value )
        { BPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : char
        { BUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of char
        { BUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                       	      string description ) : array
        { BUNPACKMDARRAY %%level };
}

type ref = null {
    kind = ref;
    reference;
    bytecode inline operator "==" ( x, y : ref ) : bool
	{ PEQBOOL };
    bytecode inline operator "!=" ( x, y : ref ) : bool
	{ PNEBOOL };
    bytecode inline operator "!" ( x : ref ) : bool
	{ PZBOOL };
};

type blob = null {
    kind = ref;
    reference;
    bytecode inline operator "==" ( x, y : ref ) : bool
	{ PEQBOOL };
    bytecode inline operator "!=" ( x, y : ref ) : bool
	{ PNEBOOL };
    bytecode inline operator "!" ( x : ref ) : bool
	{ PZBOOL };
};

type array = {
    kind = ref;
    reference;
    bytecode inline operator "==" ( x, y : array ) : bool
	{ PEQBOOL };
    bytecode inline operator "!=" ( x, y : array ) : bool
	{ PNEBOOL };
    bytecode inline operator "!" ( x : array ) : bool
	{ PZBOOL };
    bytecode inline operator "next" ( x : array )
	{ ADVANCE };
};

type struct = {
	kind = ref;
	reference;
	//size = sizeof native "void*";
	bytecode inline operator "==" ( x, y : ref ) : bool
		{ PEQBOOL };
	bytecode inline operator "!=" ( x, y : ref ) : bool
		{ PNEBOOL };
	bytecode inline operator "!" ( x : ref ) : bool
		{ PZBOOL };
}

type procedure = {
	kind = ref;
	reference;
	size = sizeof native "void*";
	bytecode inline operator "==" ( x, y : ref ) : bool
		{ PEQBOOL };
	bytecode inline operator "!=" ( x, y : ref ) : bool
		{ PNEBOOL };
	bytecode inline operator "!" ( x : ref ) : bool
		{ PZBOOL };
}

type file = ?{
    suffix = "file"; // just to avoid empty suffix conflicts with enum types...
    reference;

    bytecode inline operator "==" ( x, y : ref ) : bool
	{ PEQBOOL };
    bytecode inline operator "!=" ( x, y : ref ) : bool
	{ PNEBOOL };
    bytecode inline operator "!" ( x : ref ) : bool
	{ PZBOOL };
}

type byte = {
    size = sizeof native "char";
    kind = integer;
    suffix = "B";

    inline bytecode operator "+" ( i : byte ) : byte
        { /* do nothing */ };
    inline bytecode operator "-" ( i : byte ) : byte
        { BNEG };

    inline bytecode operator "+" ( i : byte; j : byte ) : byte
        { BADD };
    inline bytecode operator "-" ( i : byte; j : byte ) : byte
        { BSUB };
    inline bytecode operator "*" ( i : byte; j : byte ) : byte
        { BMUL };
    inline bytecode operator "/" ( i : byte; j : byte ) : byte
        { BDIV };
    inline bytecode operator "%" ( i : byte; j : byte ) : byte
        { BMOD };

    bytecode inline operator "<" ( x, y : byte ) : bool
        { BLTBOOL };
    bytecode inline operator ">" ( x, y : byte ) : bool
        { BGTBOOL };
    bytecode inline operator "<=" ( x, y : byte ) : bool
        { BLEBOOL };
    bytecode inline operator ">=" ( x, y : byte ) : bool
        { BGEBOOL };
    bytecode inline operator "==" ( x, y : byte ) : bool
        { BEQBOOL };
    bytecode inline operator "!=" ( x, y : byte ) : bool
        { BNEBOOL };

    bytecode inline operator "shl" ( x, y : byte ) : byte
	{ BSHL };
    bytecode inline operator "shr" ( x, y : byte ) : byte
	{ BSHR };
    bytecode inline operator "&" ( x, y : byte ) : byte
	{ BAND };
    bytecode inline operator "|" ( x, y : byte ) : byte
	{ BOR };
    bytecode inline operator "^" ( x, y : byte ) : byte
	{ BXOR };

    inline bytecode operator "++" ( i : byte ) : byte
        { BINC };
    inline bytecode operator "--" ( i : byte ) : byte
        { BDEC };
    inline bytecode operator "incvar" ()
        { BINCVAR };
    inline bytecode operator "decvar" ()
        { BDECVAR };
    inline bytecode operator "." ( i : byte )
        { BPRINT };
    inline bytecode operator "<" ( i : byte )
        { BPRINT };

    inline bytecode operator "@byte" ( i : byte ) : byte {};

    bytecode inline operator "jnz" ( x : byte )
        { BJNZ };
    bytecode inline operator "jz" ( x : byte )
        { BJZ };

    inline bytecode operator "ldc" () : byte
        { BLDCS };

    inline bytecode operator "loop" ( counter : addressof; range : byte )
        { BLOOP };

    inline bytecode operator "[]" ( a : array; i : byte ) : addressof
        { BINDEX };

    inline bytecode operator "new[]" ( i : byte ) : array
        { BAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : byte ) : blob
        { BBLOB };

    inline bytecode operator "new[][]" ( i : byte ) : array
        { BMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "%%" ( format : string; x : byte ) : string
        { BSPRINTF };

    inline bytecode operator "%%" ( x : byte ) : string
        { SLDC "%hhd" SWAP BSPRINTF };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; byte value )
        { BPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; byte[] value )
        { BPACKARRAY };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : byte
        { BUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of byte
        { BUNPACKARRAY };

    inline bytecode operator "nth-byte"( byte i; int index ): byte
        { BNthBYTE };
}

type short = {
    size = sizeof native "short";
    kind = integer;
    suffix = "S";

    inline bytecode operator "+" ( i : short ) : short
        { /* do nothing */ };
    inline bytecode operator "-" ( i : short ) : short
        { HNEG };

    inline bytecode operator "+" ( i : short; j : short ) : short
        { HADD };
    inline bytecode operator "-" ( i : short; j : short ) : short
        { HSUB };
    inline bytecode operator "*" ( i : short; j : short ) : short
        { HMUL };
    inline bytecode operator "/" ( i : short; j : short ) : short
        { HDIV };
    inline bytecode operator "%" ( i : short; j : short ) : short
        { HMOD };

    bytecode inline operator "<" ( x, y : short ) : bool
        { HLTBOOL };
    bytecode inline operator ">" ( x, y : short ) : bool
        { HGTBOOL };
    bytecode inline operator "<=" ( x, y : short ) : bool
        { HLEBOOL };
    bytecode inline operator ">=" ( x, y : short ) : bool
        { HGEBOOL };
    bytecode inline operator "==" ( x, y : short ) : bool
        { HEQBOOL };
    bytecode inline operator "!=" ( x, y : short ) : bool
        { HNEBOOL };

    bytecode inline operator "shl" ( x, y : short ) : short
	{ HSHL };
    bytecode inline operator "shr" ( x, y : short ) : short
	{ HSHR };
    bytecode inline operator "&" ( x, y : short ) : short
	{ HAND };
    bytecode inline operator "|" ( x, y : short ) : short
	{ HOR };
    bytecode inline operator "^" ( x, y : short ) : short
	{ HXOR };

    inline bytecode operator "++" ( i : short ) : short
        { HINC };
    inline bytecode operator "--" ( i : short ) : short
        { HDEC };
    inline bytecode operator "incvar" ()
        { HINCVAR };
    inline bytecode operator "decvar" ()
        { HDECVAR };

    inline bytecode operator "." ( i : short )
        { HPRINT };
    inline bytecode operator "<" ( i : short )
        { HPRINT };

    inline bytecode operator "<<" ( f : file; i : short ) : file
    	{ HFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : short
    	{ HFILESCAN };

    inline bytecode operator "%%" ( format : string; x : short ) : string
        { HSPRINTF };

    inline bytecode operator "%%" ( x : short ) : string
        { SLDC "%hd" SWAP HSPRINTF };

    inline bytecode operator "ldc" () : short
        { HLDCS };

    inline bytecode operator "loop" ( counter : addressof; range : short )
        { HLOOP };

    inline bytecode operator "[]" ( a : array; i : short ) : addressof
        { HINDEX };

    inline bytecode operator "new[]" ( i : short ) : array
        { HAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : short ) : blob
        { HBLOB };

    inline bytecode operator "new[][]" ( i : short ) : array
        { HMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; short value )
        { HPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; 
				     	  array of short value )
        { HPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; 
				     	    array value )
        { HPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : short
        { HUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : 
					    array of short
        { HUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                      	      string description ) : array
        { HUNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( short i; int index ): byte
        { HNthBYTE };
}

type int = {
    size = sizeof native "int";
    kind = integer;

    inline bytecode operator "+" ( i : int ) : int
        { /* do nothing */ };
    inline bytecode operator "-" ( i : int ) : int
        { NEG };

    inline bytecode operator "+" ( i : int; j : int ) : int
        { ADD };
    inline bytecode operator "-" ( i : int; j : int ) : int
        { SUB };
    inline bytecode operator "*" ( i : int; j : int ) : int
        { MUL };
    inline bytecode operator "/" ( i : int; j : int ) : int
        { DIV };
    inline bytecode operator "%" ( i : int; j : int ) : int
        { MOD };

    bytecode inline operator "<" ( x, y : int ) : bool
        { LTBOOL };
    bytecode inline operator ">" ( x, y : int ) : bool
        { GTBOOL };
    bytecode inline operator "<=" ( x, y : int ) : bool
        { LEBOOL };
    bytecode inline operator ">=" ( x, y : int ) : bool
        { GEBOOL };
    bytecode inline operator "==" ( x, y : int ) : bool
        { EQBOOL };
    bytecode inline operator "!=" ( x, y : int ) : bool
        { NEBOOL };

    bytecode inline operator "shl" ( x, y : int ) : int
	{ SHL };
    bytecode inline operator "shr" ( x, y : int ) : int
	{ SHR };
    bytecode inline operator "&" ( x, y : int ) : int
	{ AND };
    bytecode inline operator "|" ( x, y : int ) : int
	{ OR };
    bytecode inline operator "^" ( x, y : int ) : int
	{ XOR };

    inline bytecode operator "++" ( i : int ) : int
        { INC };
    inline bytecode operator "--" ( i : int ) : int
        { DEC };
    inline bytecode operator "incvar" ()
        { INCVAR };
    inline bytecode operator "decvar" ()
        { DECVAR };
    inline bytecode operator "." ( i : int )
        { IPRINT };
    inline bytecode operator "<" ( i : int )
        { IPRINT };

    inline bytecode operator "@int" ( i : byte ) : int
        { BEXTEND HEXTEND };

    inline bytecode operator "@int" ( i : short ) : int
        { HEXTEND };

    inline bytecode operator "<<" ( f : file; i : int ) : file
    	{ FILEPRINT };

    inline bytecode operator ">>" ( f : file ) : int
    	{ FILESCAN };

    inline bytecode operator "%%" ( format : string; x : int ) : string
        { ISPRINTF };

    inline bytecode operator "%%" ( x : int ) : string
        { SLDC "%d" SWAP ISPRINTF };

    bytecode inline operator "jnz" ( x : int )
        { JNZ };
    bytecode inline operator "jz" ( x : int )
        { JZ };

    inline bytecode operator "ldc" () : int
        { LDCS };

    inline bytecode operator "loop" ( counter : addressof; range : int )
        { LOOP };

    inline bytecode operator "[]" ( a : array; i : int ) : addressof
        { INDEX };

    inline bytecode operator "[..]" ( a : array; lower, upper : int ) : array
        { SUBARRAY };

    inline bytecode operator "new[]" ( i : int ) : array
        { AALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : int ) : blob
        { BLOB };

    inline bytecode operator "new[][]" ( i : int ) : array
        { MDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "exceptionval" ( p : ref ) : int
        { ERRORCODE };

    inline bytecode operator "exceptionset" ( i : int ) : int
        { /* empty */ };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; int value )
        { PACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; 
				     	  array of int value )
        { PACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; 
				     	    array value )
        { PACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : int
        { UNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of int
        { UNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                      	      string description ) : array
        { UNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( int i; int index ): byte
        { NthBYTE };

    /* The "last" operator provides teh index of the last array "a"
    element is is necessary to compile an 'a[i:]' construct with the
    correct type of the upper limit (the type must be the same as of
    variable 'i': */

    inline bytecode operator "last"( a : array ): int
        { LENGTH DEC }
}

type long = {
    size = sizeof native "long";
    kind = integer;
    suffix = "L";

    inline bytecode operator "+" ( i : long ) : long
        { /* do nothing */ };
    inline bytecode operator "-" ( i : long ) : long
        { LNEG };

    inline bytecode operator "+" ( i : long; j : long ) : long
        { LADD };
    inline bytecode operator "-" ( i : long; j : long ) : long
        { LSUB };
    inline bytecode operator "*" ( i : long; j : long ) : long
        { LMUL };
    inline bytecode operator "/" ( i : long; j : long ) : long
        { LDIV };
    inline bytecode operator "%" ( i : long; j : long ) : long
        { LMOD };

    bytecode inline operator "<" ( x, y : long ) : bool
        { LLTBOOL };
    bytecode inline operator ">" ( x, y : long ) : bool
        { LGTBOOL };
    bytecode inline operator "<=" ( x, y : long ) : bool
        { LLEBOOL };
    bytecode inline operator ">=" ( x, y : long ) : bool
        { LGEBOOL };
    bytecode inline operator "==" ( x, y : long ) : bool
        { LEQBOOL };
    bytecode inline operator "!=" ( x, y : long ) : bool
        { LNEBOOL };

    bytecode inline operator "shl" ( x, y : long ) : long
	{ LSHL };
    bytecode inline operator "shr" ( x, y : long ) : long
	{ LSHR };
    bytecode inline operator "&" ( x, y : long ) : long
	{ LAND };
    bytecode inline operator "|" ( x, y : long ) : long
	{ LOR };
    bytecode inline operator "^" ( x, y : long ) : long
	{ LXOR };

    inline bytecode operator "++" ( i : long ) : long
        { LINC };
    inline bytecode operator "--" ( i : long ) : long
        { LDEC };
    inline bytecode operator "incvar" ()
        { LINCVAR };
    inline bytecode operator "decvar" ()
        { LDECVAR };

    inline bytecode operator "." ( i : long )
        { LPRINT };

    inline bytecode operator "<" ( i : long )
        { LPRINT };

    inline bytecode operator "<<" ( f : file; i : long ) : file
    	{ LFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : long
    	{ LFILESCAN };

    inline bytecode operator "%%" ( format : string; x : long ) : string
        { LSPRINTF };

    inline bytecode operator "%%" ( x : long ) : string
        { SLDC "%ld" SWAP LSPRINTF };

    inline bytecode operator "@long" ( i : short ) : long
        { HEXTEND EXTEND };

    inline bytecode operator "@long" ( i : int ) : long
        { EXTEND };

    inline bytecode operator "ldc" () : long
        { LLDCS };

    inline bytecode operator "loop" ( counter : addressof; range : long )
        { LLOOP };

    inline bytecode operator "[]" ( a : array; i : long ) : addressof
        { LINDEX };

    inline bytecode operator "[..]" ( a : array; lower, upper : long ) : array
        { LSUBARRAY };

    inline bytecode operator "new[]" ( i : long ) : array
        { LAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : long ) : blob
        { LBLOB };

    inline bytecode operator "new[][]" ( i : long ) : array
        { LMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; long value )
        { LPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; 
				     	  array of long value )
        { LPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; 
				     	    array value )
        { LPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : long
        { LUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : 
                                                array of long
        { LUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                      	      string description ) : array
        { LUNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( long i; int index ): byte
        { LNthBYTE };

    /* The "last" operator provides teh index of the last array "a"
    element is is necessary to compile an 'a[i:]' construct with the
    correct type of the upper limit (the type must be the same as of
    variable 'i': */

    inline bytecode operator "last"( a : array ): long
        { LLENGTH LDEC }
}

type llong = {
    size = sizeof native "llong";
    kind = integer;
    suffix = "LL";

    inline bytecode operator "+" ( i : llong ) : llong
        { /* do nothing */ };
    inline bytecode operator "-" ( i : llong ) : llong
        { LLNEG };

    inline bytecode operator "+" ( i : llong; j : llong ) : llong
        { LLADD };
    inline bytecode operator "-" ( i : llong; j : llong ) : llong
        { LLSUB };
    inline bytecode operator "*" ( i : llong; j : llong ) : llong
        { LLMUL };
    inline bytecode operator "/" ( i : llong; j : llong ) : llong
        { LLDIV };
    inline bytecode operator "%" ( i : llong; j : llong ) : llong
        { LLMOD };

    bytecode inline operator "<" ( x, y : llong ) : bool
        { LLTBOOL };
    bytecode inline operator ">" ( x, y : llong ) : bool
        { LLGTBOOL };
    bytecode inline operator "<=" ( x, y : llong ) : bool
        { LLLEBOOL };
    bytecode inline operator ">=" ( x, y : llong ) : bool
        { LLGEBOOL };
    bytecode inline operator "==" ( x, y : llong ) : bool
        { LLEQBOOL };
    bytecode inline operator "!=" ( x, y : llong ) : bool
        { LLNEBOOL };

    bytecode inline operator "shl" ( x, y : llong ) : llong
	{ LLSHL };
    bytecode inline operator "shr" ( x, y : llong ) : llong
	{ LLSHR };
    bytecode inline operator "&" ( x, y : llong ) : llong
	{ LLAND };
    bytecode inline operator "|" ( x, y : llong ) : llong
	{ LLOR };
    bytecode inline operator "^" ( x, y : llong ) : llong
	{ LLXOR };

    inline bytecode operator "++" ( i : llong ) : llong
        { LLINC };
    inline bytecode operator "--" ( i : llong ) : llong
        { LLDEC };
    inline bytecode operator "incvar" ()
        { LLINCVAR };
    inline bytecode operator "decvar" ()
        { LLDECVAR };

    inline bytecode operator "." ( i : llong )
        { LLPRINT };
    inline bytecode operator "<" ( i : llong )
        { LLPRINT };

    inline bytecode operator "<<" ( f : file; i : llong ) : file
    	{ LLFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : llong
    	{ LLFILESCAN };

    inline bytecode operator "%%" ( format : string; x : llong ) : string
        { LLSPRINTF };

    inline bytecode operator "%%" ( x : llong ) : string
        { SLDC "%lld" SWAP LLSPRINTF };

    inline bytecode operator "@llong" ( i : short ) : llong
        { HEXTEND EXTEND LEXTEND };

    inline bytecode operator "@llong" ( i : int ) : llong
        { EXTEND LEXTEND };

    inline bytecode operator "@llong" ( i : long ) : llong
        { LEXTEND };

    inline bytecode operator "ldc" () : llong
        { LLLDCS };

    inline bytecode operator "loop" ( counter : addressof; range : llong )
        { LLLOOP };

    inline bytecode operator "[]" ( a : array; i : llong ) : addressof
        { LLINDEX };

    inline bytecode operator "new[]" ( i : llong ) : array
        { LLAALLOC %%element_size %%element_nref };

    inline bytecode operator "blob[]" ( i : llong ) : blob
        { LBLOB };

    inline bytecode operator "new[][]" ( i : llong ) : array
        { LLMDALLOCC %%element_size %%element_nref %%level };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; llong value )
        { LLPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; 
				     	  array of llong value )
        { LLPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; 
				     	    array value )
        { LLPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : long
        { LLUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : 
                                                array of llong
        { LLUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                      	      string description ) : array
        { LLUNPACKMDARRAY %%level };

    inline bytecode operator "nth-byte"( llong i; int index ): byte
        { LLNthBYTE };
}

type float = {
    size = sizeof native "float";
    kind = real;
    suffix = "";

    inline bytecode operator "+" ( i : float ) : float
        { /* do nothing */ };
    inline bytecode operator "-" ( i : float ) : float
        { FNEG };

    inline bytecode operator "+" ( i : float; j : float ) : float
        { FADD };
    inline bytecode operator "-" ( i : float; j : float ) : float
        { FSUB };
    inline bytecode operator "*" ( i : float; j : float ) : float
        { FMUL };
    inline bytecode operator "/" ( i : float; j : float ) : float
        { FDIV };
(*
    inline bytecode operator "**" ( i : float; j : float ) : float
        { FPOW };
*)
    bytecode inline operator "<" ( x, y : float ) : bool
        { FLTBOOL };
    bytecode inline operator ">" ( x, y : float ) : bool
        { FGTBOOL };
    bytecode inline operator "<=" ( x, y : float ) : bool
        { FLEBOOL };
    bytecode inline operator ">=" ( x, y : float ) : bool
        { FGEBOOL };
    bytecode inline operator "==" ( x, y : float ) : bool
        { FEQBOOL };
    bytecode inline operator "!=" ( x, y : float ) : bool
        { FNEBOOL };

    inline bytecode operator "." ( i : float )
        { FPRINT };
    inline bytecode operator "<" ( i : float )
        { FPRINT };

    inline bytecode operator "<<" ( f : file; x : float ) : file
    	{ FFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : float
    	{ FFILESCAN };

    inline bytecode operator "%%" ( format : string; x : float ) : string
        { FSPRINTF };

    inline bytecode operator "%%" ( x : float ) : string
        { SLDC "%g" SWAP FSPRINTF };

    // inline bytecode operator "@float" ( i : float ) : float {};

    inline bytecode operator "@float" ( i : short ) : float
        { EXTEND I2F };

    inline bytecode operator "@float" ( i : int ) : float
        { I2F };

    inline bytecode operator "@float" ( i : long ) : float
        { L2F };

    inline bytecode operator "@float" ( i : llong ) : float
        { LL2F };

    inline bytecode operator "ldc" () : float
        { FLDCS };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; float value )
        { FPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; float[] value )
        { FPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; array value )
        { FPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : float
        { FUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of float
        { FUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                       	      string description ) : array
        { FUNPACKMDARRAY %%level };
}

type double = {
    size = sizeof native "double";
    kind = real;
    suffix = "D";

    inline bytecode operator "+" ( i : double ) : double
        { /* do nothing */ };
    inline bytecode operator "-" ( i : double ) : double
        { DNEG };

    inline bytecode operator "+" ( i : double; j : double ) : double
        { DADD };
    inline bytecode operator "-" ( i : double; j : double ) : double
        { DSUB };
    inline bytecode operator "*" ( i : double; j : double ) : double
        { DMUL };
    inline bytecode operator "/" ( i : double; j : double ) : double
        { DDIV };
(*
    inline bytecode operator "**" ( i : double; j : double ) : double
        { DPOW };
*)
    bytecode inline operator "<" ( x, y : double ) : bool
        { DLTBOOL };
    bytecode inline operator ">" ( x, y : double ) : bool
        { DGTBOOL };
    bytecode inline operator "<=" ( x, y : double ) : bool
        { DLEBOOL };
    bytecode inline operator ">=" ( x, y : double ) : bool
        { DGEBOOL };
    bytecode inline operator "==" ( x, y : double ) : bool
        { DEQBOOL };
    bytecode inline operator "!=" ( x, y : double ) : bool
        { DNEBOOL };

    inline bytecode operator "." ( i : double )
        { DPRINT };
    inline bytecode operator "<" ( i : double )
        { DPRINT };

    inline bytecode operator "<<" ( f : file; x : double ) : file
    	{ DFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : double
    	{ DFILESCAN };

    inline bytecode operator "%%" ( format : string; x : double ) : string
        { DSPRINTF };

    inline bytecode operator "%%" ( x : double ) : string
        { SLDC "%g" SWAP DSPRINTF };

    inline bytecode operator "@float" ( i : short ) : float
        { EXTEND I2D };

    inline bytecode operator "@double" ( i : int ) : double
        { I2D };

    inline bytecode operator "@double" ( i : long ) : double
        { L2D };

    inline bytecode operator "@double" ( i : llong ) : double
        { LL2D };

    inline bytecode operator "@double" ( i : float ) : double
        { F2D };

    inline bytecode operator "ldc" () : double
        { DLDCS };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; double value )
        { DPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; double[] value )
        { DPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; array value )
        { DPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : double
        { DUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of double
        { DUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                       	      string description ) : array
        { DUNPACKMDARRAY %%level };
}

type ldouble = {
    size = sizeof native "ldouble";
    kind = real;
    suffix = "LD";

    inline bytecode operator "+" ( i : ldouble ) : ldouble
        { /* do nothing */ };
    inline bytecode operator "-" ( i : ldouble ) : ldouble
        { LDNEG };

    inline bytecode operator "+" ( i : ldouble; j : ldouble ) : ldouble
        { LDADD };
    inline bytecode operator "-" ( i : ldouble; j : ldouble ) : ldouble
        { LDSUB };
    inline bytecode operator "*" ( i : ldouble; j : ldouble ) : ldouble
        { LDMUL };
    inline bytecode operator "/" ( i : ldouble; j : ldouble ) : ldouble
        { LDDIV };
(*
    inline bytecode operator "**" ( i : ldouble; j : ldouble ) : ldouble
        { LDPOW };
*)
    bytecode inline operator "<" ( x, y : ldouble ) : bool
        { LDLTBOOL };
    bytecode inline operator ">" ( x, y : ldouble ) : bool
        { LDGTBOOL };
    bytecode inline operator "<=" ( x, y : ldouble ) : bool
        { LDLEBOOL };
    bytecode inline operator ">=" ( x, y : ldouble ) : bool
        { LDGEBOOL };
    bytecode inline operator "==" ( x, y : ldouble ) : bool
        { LDEQBOOL };
    bytecode inline operator "!=" ( x, y : ldouble ) : bool
        { LDNEBOOL };

    inline bytecode operator "." ( i : ldouble )
        { LDPRINT };
    inline bytecode operator "<" ( i : ldouble )
        { LDPRINT };

    inline bytecode operator "<<" ( f : file; x : ldouble ) : file
    	{ LDFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : ldouble
    	{ LDFILESCAN };

    inline bytecode operator "%%" ( format : string; x : ldouble ) : string
        { LDSPRINTF };

    inline bytecode operator "%%" ( x : ldouble ) : string
        { SLDC "%Lg" SWAP LDSPRINTF };

    inline bytecode operator "@ldouble" ( i : int ) : ldouble
        { I2LD };

    inline bytecode operator "@ldouble" ( i : long ) : ldouble
        { L2LD };

    inline bytecode operator "@ldouble" ( i : llong ) : ldouble
        { LL2LD };

    inline bytecode operator "@ldouble" ( i : float ) : ldouble
        { F2LD };

    inline bytecode operator "@ldouble" ( i : double ) : ldouble
        { D2LD };

    inline bytecode operator "ldc" () : ldouble
        { LDLDCS };
}

type string = ?{
    size = sizeof native "char*";
    kind = string;
    reference;
    immutable;
    suffix = "";

    inline bytecode operator "+" ( s1, s2 : string ) : string
        { STRCAT };

    inline bytecode operator "_" ( s1, s2 : string ) : string
        { STRCAT };

    inline bytecode operator "." ( i : string )
        { SPRINT };

    inline bytecode operator "<" ( i : string )
        { SPRINT };

    inline bytecode operator "<<" ( f : file; i : string ) : file
    	{ SFILEPRINT };

    inline bytecode operator ">>" ( f : file ) : string
    	{ /*SFILESCAN*/ BLDC 10 SFILEREADLN };

    inline bytecode operator "%%" ( format : string; x : string ) : string
        { SSPRINTF };

    inline bytecode operator "%%" ( x : string ) : string
        { SLDC "%s" SWAP SSPRINTF };

    inline bytecode operator "[char]" ( s : string; i : char ) : char
        { BPCKIDX 1 CLDI };

    inline bytecode operator "[byte]" ( s : string; i : byte ) : char
        { BPCKIDX 1 CLDI };

    inline bytecode operator "[short]" ( s : string; i : short ) : char
        { HPCKIDX 1 CLDI };

    inline bytecode operator "[int]" ( s : string; i : int ) : char
        { PCKIDX 1 CLDI };

    inline bytecode operator "[long]" ( s : string; i : long ) : char
        { LPCKIDX 1 CLDI };

    inline bytecode operator "[llong]" ( s : string; i : llong ) : char
        { LPCKIDX 1 CLDI };

    inline bytecode operator "[int..int]" ( s : string; ifrom, ito : int ) : string
        { SUBSTR 1 };

    inline bytecode operator "[long..long]" ( s : string; ifrom, ito : long ) : string
        { LSUBSTR 1 };

    bytecode inline operator "==" ( x, y : string ) : bool
        { STREQ };

    bytecode inline operator "!=" ( x, y : string ) : bool
        { STRNE };

    inline bytecode operator "ldc" () : string
        { SLDC };

    inline bytecode operator "exceptionval" ( p : ref ) : string
        { ERRORMSG };

    inline bytecode operator "exceptionset" ( i : string ) : string
        { /* empty */ };

    inline bytecode operator "pack"( blob b; int offset;
                                     string description; string value )
        { STRPACK };

    inline bytecode operator "packarray"( blob b; int offset;
                                     	  string description; string[] value )
        { STRPACKARRAY };

    inline bytecode operator "packmdarray"( blob b; int offset;
                                     	    string description; array value )
        { STRPACKMDARRAY %%level };

    inline bytecode operator "unpack"( blob b; int offset;
                                       string description ) : string
        { STRUNPACK };

    inline bytecode operator "unpackarray"( blob b; int offset;
                                       	    string description ) : array of string
        { STRUNPACKARRAY };

    inline bytecode operator "unpackmdarray"( blob b; int offset;
                                       	      string description ) : array
        { STRUNPACKMDARRAY %%level };
}

#
# Functions to obtain array lengths (can be used also for strings, but
# will not yield strlen since they will count also the terminating
# null character.
#

inline bytecode function length( m : ref ) : int
{
    LENGTH
}

inline bytecode function llength( m : ref ) : long
{
    LLENGTH
}

inline bytecode function last( m : ref ) : int
{
    LENGTH LDC 1 SUB
}

inline bytecode function llast( m : ref ) : long
{
    LLENGTH LLDC 1 LSUB
}

inline bytecode function nref( m : ref ) : int
{
    NREF
}

inline bytecode function lnref( m : ref ) : long
{
    LNREF
}

inline bytecode function capacity( m : array ) : int
{
    CAPACITY
}

inline bytecode function lcapacity( m : array ) : long
{
    LCAPACITY
}

#
# Pushing an poping to the arrays:
#

inline bytecode procedure push( a : array of type T; value : type T )
    -> array of type T
{
    APUSH
}

inline bytecode procedure pop( a : array of type T ) : type T
{
    APOP
}

inline bytecode function trim( a : array of type T ): array of type T
{
    TRIM
}

#
# String comparison functions
#

inline bytecode function strstart( prefix, str : string ) : bool
{
    STRSTART
}

inline bytecode function strend( suffix, str : string ) : bool
{
    STREND
}

inline bytecode function strlen( str : string ) : long
{
    STRLEN
}

inline bytecode function strindex( haystack, needle : string ) : long
{
    STRINDEX
}

inline bytecode function strchr( haystack: string; needle: char  ) : long
{
    STRCHR
}

inline bytecode function strrchr( haystack: string; needle: char ) : long
{
    STRRCHR
}

#
# String conversions:
#

inline bytecode function atob( s: string ): byte
{
    ATOB
}

inline bytecode function atoh( s: string ): short
{
    ATOH
}

inline bytecode function atoi( s: string ): int
{
    ATOI
}

inline bytecode function atol( s: string ): long
{
    ATOL
}

inline bytecode function atoll( s: string ): llong
{
    ATOLL
}

inline bytecode function strtob( s: string; base: int = 0 ): byte, long
{
    STRTOB
}

inline bytecode function strtoh( s: string; base: int = 0 ): short, long
{
    STRTOH
}

inline bytecode function strtoi( s: string; base: int = 0 ): int, long
{
    STRTOI
}

inline bytecode function strtol( s: string; base: int = 0 ): long, long
{
    STRTOL
}

inline bytecode function strtoll( s: string; base: int = 0 ): llong, long
{
    STRTOLL
}

inline bytecode function strtof( s: string ): float, long
{
    STRTOF
}

inline bytecode function strtod( s: string ): double, long
{
    STRTOD
}

inline bytecode function strtold( s: string ): ldouble, long
{
    STRTOLD
}

#
# Narrowing of integers -- raise exceptions if the numbers do
# not fit into destinations:
#

inline bytecode function lowbyte( short s ) : byte
{
    LOWBYTE
}

inline bytecode function lowshort( int i ) : short
{
    LOWSHORT
}

inline bytecode function lowint( long l ) : int
{
    LOWINT
}

inline bytecode function lowlong( llong l ) : long
{
    LOWLONG
}

#
# Type conversion functions: rounding
#

inline bytecode function lddouble( x : ldouble ) : double
{
    LDDOUBLE
}

inline bytecode function dfloat( x : double ) : float
{
    DFLOAT
}

inline bytecode function ldfloat( x : ldouble ) : float
{
    LDDOUBLE DFLOAT
}

#
# The libc exit() function:
#

inline bytecode function exit( int exit_code )
{
    EXIT
}

#
# Deep cloning of objects and arrays:
#

inline bytecode 
function clone( m : array of type T; int level = 1 ): array of T
{ DEEPCLONE }
