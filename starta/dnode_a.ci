/*--*-C-*--------------------------------------------------------------------*\
**$Author$
**$Date$ 
**$Revision$
**$URL$
\*---------------------------------------------------------------------------*/

/* private allocator for dnodes */

#include <stdio.h>
#include <stdlib.h>
#include <cexceptions.h>
#include <allocx.h>

#if 0
#define USE_FIXED_NODE_ARRAY
#endif

/* The doubly-linked list of allocated DNODEs: */
static DNODE *allocated = NULL;
static intmax_t maxalloc;

static void dnode_exclude_from_allocated_list( DNODE *dnode )
{
    if( dnode ) {
        if( allocated == dnode ) {
            allocated = dnode->next_alloc;
        }
        if( dnode->prev_alloc ) {
            dnode->prev_alloc->next_alloc = dnode->next_alloc;
        }
        if( dnode->next_alloc ) {
            dnode->next_alloc->prev_alloc = dnode->prev_alloc;
        }
    }
}

#ifdef USE_FIXED_NODE_ARRAY

#define MAX_DNODES 100000

static DNODE dnodes[MAX_DNODES];
static long last_dnode;

static DNODE *alloc_dnode( cexception_t *ex )
{
    /* return callocx( sizeof(DNODE), 1, ex ); */
    assert( last_dnode < MAX_DNODES );
    /* printf( "allocating dnode %ld\n", last_dnode ); */
    TNODE *node = &dnodes[last_dnode++];
    if( allocated ) {
        allocated->prev_alloc = node;
    }
    node->next_alloc = allocated;
    allocated = node;
    maxalloc ++;
    return node;
}

static void free_dnode( DNODE *dnode )
{
    /* freex( dnode ); return; */
    /* printf( "deleting dnode %d\n", (dnode-dnodes) ); */
    assert( dnode->rcount == 0 );
    dnode_exclude_from_allocated_list( dnode );
    dnode->rcount--;
}

void deallocate_all_dnodes( void )
{
    DNODE *node;
    for( node = allocated; node != NULL; node = node->next_alloc ) {
        deallocate_dnode_buffers( node );
    }
    allocated = NULL;
}

#else

static DNODE *alloc_dnode( cexception_t *ex )
{
    DNODE *node = callocx( sizeof(DNODE), 1, ex );
    if( allocated ) {
        allocated->prev_alloc = node;
    }
    node->next_alloc = allocated;
    allocated = node;
    maxalloc ++;
    return node;
}

static void free_dnode( DNODE *dnode )
{
    assert( dnode->rcount == 0 );
    dnode_exclude_from_allocated_list( dnode );
    freex( dnode );
}

void deallocate_all_dnodes( void )
{
    DNODE *node, *next;
    for( node = allocated; node != NULL; ) {
        next = node->next_alloc;
        deallocate_dnode_buffers( node );
        freex( node );
        node = next;
    }
    allocated = NULL;
}

#endif

void dnode_print_allocated()
{
    dnode_fprint_allocated( stdout );
}

void dnode_print_allocated_to_stderr()
{
    dnode_fprint_allocated( stderr );
}

void dnode_fprint_allocated( FILE *fp )
{
    DNODE *node;
    fprintf( fp, "MAX DNODES: %jd\n", maxalloc );
    for( node = allocated; node != NULL; node = node->next_alloc ) {
        fprintf( fp, "DNODE: %p rcount = %d rcount2 = %d \"%s\" type = \"%s\" "
                 "next = %p prev = %p\n", node, node->rcount,
                 node->rcount2, node->name,
                 node->tnode ? tnode_name( node->tnode ) : "",
                 node->next, node->prev );
    }
}
