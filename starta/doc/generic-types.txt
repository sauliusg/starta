Redesign the type system
========================

The following kinds of types should be present in the end:

- placeholder: 

type T in the 'type dictionary of T =' declarations that will be 
replaced by concrete types during instantiation;

- some (any?) type designators:

type T in 'x : array of some type T' designations, indicating that an 
aggregate some type T will be used in a function call, but we do not 
know what type when compiling the function. The only limitations is that 
types with different names are incompatible;

- generic types:

type T in 'type T = generic ref'; it indicates what implementation shold 
be used for the type; compiles with type erasure and must be 
instantiated using 'with' clause;

- synonims, with possible operator extensions:

type T in 'type T = int { operator "**" (T x; T p): T }'. The declared 
type T must be treated as 'int' for all compatibility purposes, but can 
have additional operators;

Curretnly designated using the 'LIKE' keyword.

- new types (?):

'type T = new int' â€“ possibly; the type T inherits implementation from 
'int' but is otherwise incompatible with int. Can be converted to/from 
int.
