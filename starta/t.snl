#
# Snail compiler tests
#
#
# Generic lists.
#

use * from std;

type list of T = ?{
    next : list of T;
    value : T;

    operator "+" ( l1, l2 : list of T ) : list of T
    {
	if( l1 && l2 ) {
	    var r = l1[];
	    var q = r;
	    var p = l1.next;
	    while( p != null ) {
		q.next = p[];
		q = q.next;
		p = p.next;
	    }
	    q.next = l2;
	    return r
	} else {
	    if( l1 ) {
		return l1
	    } else {
		return l2
	    }
	}
    }; // operator "+"

    inline bytecode operator "new" () : list of T
    { ALLOC %%alloc_size %%nref };

    inline bytecode operator "@list" ( i : T ) : list of T
    {
      ALLOC %%alloc_size %%nref
      // LDC %%alloc_size IPRINT NEWLINE
      // LDC %%nref IPRINT NEWLINE
      // ALLOC 12 %%nref
      DUP
      OFFSET  const((list of T).value.offset)
      ROT ROT STI const(int.size)
      // OFFSET %.value
      // OFFSET %%.value.offset
      // ROT ROT %%sti %%.value.size
      // ROT ROT %%sti (%%.value.is_ref? %%.value.size : "")
      // ROT ROT %%value.sti  // should compile to one or two
                              // codecells, depending on the concrete type
                              // of the "value".
    };

    inline bytecode operator "*" ( l : list of T ) : addressof
    { OFFSET %.value }

    inline bytecode operator "next"( l : list of T )
    { NEXT const((list of T).next.offset) %.value }

} // type "list of T"

procedure cons( s : list of type T; l : list of type T = null ) : list of type T
{
    s.next = l;
    return s;
}

procedure cat( l1, l2 : list of T ) : list of T
{
    l1.next = l2;
    return l1
}

exception NullPointerException;

procedure tail( l : list of type T ) : list of T
{
    if( l ) {
        return l.next
    } else {
        return null;
    }
}

// Need:

# operator 'new' : -> list of T
# operator '[]' : list of T -> address of T
# Operator 'cat': +, _
# Operator 'cons': ::
# Operator 'head': @
# Operator 'tail': _ (unary)

var l, p : list of int;

var s : list of int = new list of int;

s = (156,);

l = s + p;
l = s + cons( (2,) );
l = l + cons( (11,),
              (22,) ) +
        cons( (3,),
              cons( (4,) ));
// < "( ";
// foreach var i in l do
//     < i, ""
// enddo
// . " )";

< "( ";
< *l;
< " ";
< *tail(l);
< " ";
< *tail(tail(l));
. " )";


. *(2.3,);

. *("labas",);
