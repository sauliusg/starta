#! /usr/bin/env starta
/*--*- Java -*---------------------------------------------------------------*\
**$Author: saulius $
**$Date: 2020-04-23 16:44:32 +0300 (Thu, 23 Apr 2020) $ 
**$Revision: 6937 $
**$URL: svn+ssh://saulius.grazulis.lt/home/saulius/svn-repositories/paskaitos/VU/software/trunk/bioinformatika-III-assignments/bin/pdbquickhull $
\*---------------------------------------------------------------------------*/
//*
// Starta programa, kuri kiekvienam PDB(x) failui suskaičiuoja jo
// atomų iškiląjį apvalkalėlį. Algoritmas: "quick hull".
//
// Programos iškvietimas:
// pdbquickhull < 1zyx.pdb
// pdbquickhull 1zyx.pdb 2zyx*.cif
//**
    
pragma append  "$P/lib/starta";
pragma prepend "$P/lib";
    
use std;
use BiomoleculeAtom;
use PDBline;
use PDBxline;
use Math;
use Vectors;
use Lists;
use Planes;

var null_Atom = new Atom;

var Id = "$Id: pdbquickhull 6937 2020-04-23 13:44:32Z saulius $";

. "#", Id[1:-2];

// Flag which file format we are currently reading:
type format = enum byte( PDB, PDBx );
var current_format = PDB format;

exception FORMAT_ERROR;

var atom = new Atom();
var molecule: array of Atom = new Atom[0];

var long n = 0;

var bool in_text_field = false;

while(<>) {
    if( !strstart( ";", $_ ) && in_text_field ) {
        continue;
    }
    if( strstart( ";", $_ )) {
        if( in_text_field ) {
            in_text_field = false;
        } else {
            in_text_field = true;
        }
        continue;
    }
    if( strstart( "data_", $_ )) {
        current_format = PDBx format;
        continue;
    }
    if( strstart( "HEADER", $_ ) || strstart( "CRYST1", $_ ) ) {
        current_format = PDB format;
        continue;
    }
    if( current_format == PDB format && strstart( "ATOM  ", $_ ) ||
        current_format == PDBx format && strstart( "ATOM", $_ ) ||
        strstart( "HETATM", $_ )) {
        
        if( current_format == PDB format ) then
            atom = PDBline::split( $_ );
        elsif( current_format == PDBx format ) then
            atom = PDBxline::split( $_ );
        else
            raise FORMAT_ERROR( "unsupported format %d" %% current_format@int );
        endif;
        molecule = push( molecule, atom );
        atom.atomNumber = n;
        n++;
    }
}

function original_simplex( molecule: array of Atom ): int[];

function minmax( a: array of type X; cmp: function(X a[]; X b[])->(int) )
    -> X[], X[], int, int;

function abs(double x): double => x >= 0.0D ? x : -x;

function atom_distance( a1, a2 : Atom ): double
{
    var dx, dy, dz = a1.x - a2.x, a1.y - a2.y, a1.z - a2.z;
    return sqrt( dx*dx + dy*dy + dz*dz );
}

function cmpx( a, b: Atom[] ): int
{
    return a[0].x < b[0].x ? -1 : 1;
}

function cmpy( a, b: Atom[] ): int
{
    return a[0].y < b[0].y ? -1 : 1;
}

function cmpz( a, b: Atom[] ): int
{
    return a[0].z < b[0].z ? -1 : 1;
}

var original_tetrahedron = original_simplex( molecule );

struct Face {
    bool not_in_hull;
    Atom[] molecule;
    int v1, v2, v3; // Vertices used; indices in the 'molecule' array
    list of Atom outside_atoms;
    Face[] neighbours;
    bool[] edge_crossed; // Parallels the 'neighbours' array
};

var null_Face = new Face;

function tetrahedron_faces( tetrahedron: int[]; molecule: Atom[] ):
    list of Face;

var current_faces = tetrahedron_faces( original_tetrahedron, molecule );

procedure add_vertices_to_outside_set( face: Face;
    unclaimed_vertices: list of Atom ): list of Atom;

function find_nonempty_face( faces: list of Face ): Face;
function find_eye_point( face: Face ): Atom;

function face_is_visible( face: Face; eye_point: Atom ): bool
{
    var mol = face.molecule;
    var a1 = mol[face.v1];
    var a2 = mol[face.v2];
    var a3 = mol[face.v3];
    var pt1 = [a1.x, a1.y, a1.z];
    var pt2 = [a2.x, a2.y, a2.z];
    var pt3 = [a3.x, a3.y, a3.z];
    var pt = [eye_point.x, eye_point.y, eye_point.z];

    var d = pl2pt_distance( pt1, pt2, pt3, pt );

    return d < 0.0D ? true : false; 
}

procedure find_horizon( face: Face; eye_point: Atom;
                        Face previous_face ):
    list of int,  // List of horizon vertices, in cyclic order
    list of Face, // List of faces behind the horizon edges, in the same order as in
                  // the first returned value;
    list of Atom  // List of unclaimed vertices
{
    var horizon: list of int;
    var still_unclaimed: list of Atom;
    var horizon_faces: list of Face;
    var crossed_edge = -1;

    if( face.not_in_hull ) {
        return null, null, null;
    }

    if( previous_face != null_Face ) {
        for( crossed_edge = 0; crossed_edge < 3; crossed_edge ++ ) {
            if( face.neighbours[crossed_edge] == previous_face ) {
                break;
            }
        }
        assert face.neighbours[crossed_edge] == previous_face;
    }

    //D {
    //D     var m1 = molecule[face.v1];
    //D     var m2 = molecule[face.v2];
    //D     var m3 = molecule[face.v3];
    //D     . ">>>", "current_face:";
    //D     . ">>>", "v1:", m1.atomName, m1.residueName, m1.residueNumber;
    //D     . ">>>", "v2:", m2.atomName, m2.residueName, m2.residueNumber;
    //D     . ">>>", "v3:", m3.atomName, m3.residueName, m3.residueNumber;
    //D     . ">>>", "is visible:", face_is_visible( face, eye_point );
    //D     if( previous_face != null_Face ) {
    //D         . ">>>", "previous_face:";
    //D         m1 = molecule[previous_face.v1];
    //D         m2 = molecule[previous_face.v2];
    //D         m3 = molecule[previous_face.v3];
    //D         . ">>>", "v1:", m1.atomName, m1.residueName, m1.residueNumber;
    //D         . ">>>", "v2:", m2.atomName, m2.residueName, m2.residueNumber;
    //D         . ">>>", "v3:", m3.atomName, m3.residueName, m3.residueNumber;
    //D         . ">>>";
    //D     } else {
    //D         . ">>> prevous face is null";
    //D     }
    //D     assert face.edge_crossed != null;
    //D     assert face.neighbours != null;
    //D     assert face.molecule != null;
    //D }

    if( face_is_visible( face, eye_point ) ) {
        face.not_in_hull = true;
        still_unclaimed = face.outside_atoms + still_unclaimed;
        face.outside_atoms = null;

        var i = (crossed_edge + 1) % length(face.neighbours);

        var final_edge = crossed_edge < 0 ? 0 : crossed_edge;
    
        repeat {
            //D . ">>>> face i =", i;
            var edge_horizon: list of int;
            var edge_horizon_faces: list of Face;
            var edge_still_unclaimed: list of Atom;

            assert face.neighbours[i] != null_Face;
            
            // step over the edge:
            if( !face.edge_crossed[i] ) {
                face.edge_crossed[i] = true;

                //D var m1 = molecule[face.neighbours[i].v1];
                //D var m2 = molecule[face.neighbours[i].v2];
                //D var m3 = molecule[face.neighbours[i].v3];
                //D . ">>>", "stepping over the edge:", i;
                //D . ">>>", "v1:", m1.atomName, m1.residueName, m1.residueNumber;
                //D . ">>>", "v2:", m2.atomName, m2.residueName, m2.residueNumber;
                //D . ">>>", "v3:", m3.atomName, m3.residueName, m3.residueNumber;
                //D . ">>>";
                
                edge_horizon, edge_horizon_faces, edge_still_unclaimed =
                    find_horizon( face.neighbours[i], eye_point,
                                  previous_face => face );

                horizon = edge_horizon + horizon;
                horizon_faces = edge_horizon_faces + horizon_faces;
                still_unclaimed = edge_still_unclaimed + still_unclaimed;
            }

            i = (i+1) % length(face.neighbours);
        } while( i != final_edge );

        return horizon, horizon_faces, still_unclaimed;
    } else {
        var horizon_edge: list of int;

        //D . ">>>", "crossed_edge:", crossed_edge;
        //D . ">>>";

        if( crossed_edge == 0 ) {
            horizon_edge = ( face.v2, face.v1 );
        }
        if( crossed_edge == 1 ) {
            horizon_edge = ( face.v3, face.v2 );
        }
        if( crossed_edge == 2 ) {
            horizon_edge = ( face.v1, face.v3 );
        }
    
        return horizon_edge, (face,), still_unclaimed;
    }
}

// Initially, all atoms are unclaimed:

{
    var unclaimed_vertices: list of Atom;

    for( var i = last(molecule); i >= 0; i -- ) {
        unclaimed_vertices = (molecule[i],) + unclaimed_vertices;
    }

    // Find all atoms (vertices) outside the original tetrahedron:

    for var face in current_faces {
            unclaimed_vertices = add_vertices_to_outside_set( face, unclaimed_vertices );
        }
}

inline bytecode function ord( char c ): byte {};
inline bytecode function chr( byte c ): byte {};

//D == Debug print :)
//D for var idx in original_tetrahedron {
//D      var a = molecule[idx];
//D      a.chain = "X";
//D      . ">>>>", a->asString();
//D     }
//D . "";
//D 
//D var chain = 'A';
//D for var face in current_faces {
//D     for var a in face.outside_atoms {
//D             a.chain = chain;
//D             . ">>>>", a->asString();
//D         }
//D     chain = "%c" %% chr( ord(chain[0]) + 1B );
//D     }
//D . "";
//D 
//D for var v in unclaimed_vertices {
//D     v.chain = "Z";
//D     . ">>>>", v->asString();
//D     }
//D . "";

// Run the loop to enclose all vertices (atoms) into a convex hull:

//D var nn = 1;
for( var current_face = find_nonempty_face( current_faces );
     current_face != null_Face;
     current_face = find_nonempty_face( current_faces ) ) {

    //D . ">>>> step:", nn;

    var eye_point = find_eye_point( current_face );
    var horizon: list of int;
    var horizon_faces: list of Face;

    var unclaimed_vertices: list of Atom;

    horizon, horizon_faces, unclaimed_vertices =
        find_horizon( current_face, eye_point, null_Face );

    // Build a new cone:
    var cone: list of Face;

    //D for var iedge in horizon {
    //D         . ">>>", "horizon edge:", iedge;
    //D     }
    //D for var hface in horizon_faces {
    //D         . ">>>", "horison face:", hface.v1, hface.v2, hface.v3;
    //D     }
    //D . "";
            
    for var hface in horizon_faces {
            var new_face = new Face;
            new_face.molecule = hface.molecule;
            new_face.v1 = lowint(eye_point.atomNumber);
            new_face.v2 = horizon.value;
            var next_horizon_node: list of int = horizon.next;
            new_face.v3 = next_horizon_node.value;
            new_face.neighbours = null_Face * new [3];
            new_face.neighbours[1] = hface;
            new_face.edge_crossed = new bool[3];

            //D var m1 = molecule[new_face.v1];
            //D var m2 = molecule[new_face.v2];
            //D var m3 = molecule[new_face.v3];
            //D . ">>>", "v1:", m1.atomName, m1.residueName, m1.residueNumber;
            //D . ">>>", "v2:", m2.atomName, m2.residueName, m2.residueNumber;
            //D . ">>>", "v3:", m3.atomName, m3.residueName, m3.residueNumber;
            //D . ">>>";
            
            // Find the corresponding edge in the behind-the-horizon
            // face 'hface':
            if( new_face.v2 == hface.v2 && new_face.v3 == hface.v1 ) {
                hface.neighbours[0] = new_face;
            } otherwise
            if( new_face.v2 == hface.v1 && new_face.v3 == hface.v2 ) {
                hface.neighbours[0] = new_face;
            } otherwise
            if( new_face.v2 == hface.v3 && new_face.v3 == hface.v2 ) {
                hface.neighbours[1] = new_face;
            } otherwise
            if( new_face.v2 == hface.v2 && new_face.v3 == hface.v3 ) {
                hface.neighbours[1] = new_face;
            } otherwise
            if( new_face.v2 == hface.v1 && new_face.v3 == hface.v3 ) {
                hface.neighbours[2] = new_face;
            } otherwise
            if( new_face.v2 == hface.v3 && new_face.v3 == hface.v1 ) {
                hface.neighbours[2] = new_face;
            } else {
                . ">>>>>>",
                    "new_face.v1:", new_face.v1,
                    "new_face.v2:", new_face.v2,
                    "new_face.v2:", new_face.v3;
                . ">>>>>>",
                      "hface.v1:", hface.v1,
                      "hface.v2:", hface.v2,
                      "hface.v3:", hface.v3;
                assert "" == "Could not find a corresponding edge for a new facet";
            }
            // Register outer vertices:
            unclaimed_vertices =
                add_vertices_to_outside_set( new_face, unclaimed_vertices );
            // Register the new cone facet:
            cone = (new_face,) + cone;
            horizon = horizon.next.next;
        }

    // Set the cone facet neighbours:

    var prev_facet = null_Face;
    for var facet in cone {
            if( prev_facet != null_Face ) {
                // set pointer to the next facet in the cone:
                prev_facet.neighbours[2] = facet;
                // set pointer to the previous facet in the cone:
                facet.neighbours[0] = prev_facet;
            }
            prev_facet = facet;
        }
    // prev_facet is now the last facet in the cone:
    // set pointer to the next facet in the cone:
    prev_facet.neighbours[2] = cone.value;
    // set pointer to the previous facet in the cone:
    cone.value.neighbours[0] = prev_facet;
    
    // Remove faces that are not in the hull, add the rest to the
    // cone:

    for var face in current_faces {
            if( !face.not_in_hull ) {
                face.edge_crossed[0] =
                    face.edge_crossed[1] =
                    face.edge_crossed[2] = false;
                cone = (face,) + cone;
            }
        }

    // The new cone now contains all faces that are in the current
    // convex polytope and need to be processed further:
    current_faces = cone;
    
    // Debug prints:
    //D if( nn == 2 ) {
    //D     var chain = 'A';
    //D     for var face in current_faces {
    //D             for var a in face.outside_atoms {
    //D                     a.chain = chain;
    //D                     . a->asString();
    //D                 }
    //D             chain = "%c" %% chr( ord(chain[0]) + 1B );
    //D         }
    //D 
    //D     for var idx in original_tetrahedron {
    //D             var a = molecule[idx];
    //D             a.chain = "X";
    //D             . a->asString();
    //D         }
    //D 
    //D     eye_point.chain = "Y";
    //D     . eye_point->asString();
    //D 
    //D     for var v in unclaimed_vertices {
    //D             v.chain = "Z";
    //D             . v->asString();
    //D         }
    //D 
    //D     break;
    //D }

    //D nn++;
}

// Print out the convex hull:

var in_hull = new bool[length(molecule)];

for var face in current_faces {
    in_hull[face.v1] = true;
    in_hull[face.v2] = true;
    in_hull[face.v3] = true;
    }

for( var i = 0; i < length(molecule); i++ ) {
    molecule[i].atomNumber = i + 1;
    if( in_hull[i] ) {
        . molecule[i]->asString();
    }
}

// Functions declared previously as prototype (forward functions):

use Lines;

use APrint(double);

function original_simplex( molecule: array of Atom ): int[]
{
    var vertices = [-1, -1, -1, -1];

    // Atoms with extreme locations:
    var minx, maxx: Atom[] = [null_Atom], [null_Atom];

    // Indices of atoms in the 'molecule' array:
    var iminx, imaxx: int;

    minx, maxx, iminx, imaxx = minmax( molecule, cmpx );

    vertices[0] = iminx;

    //D . ">>>>", "the lowest atom is:";
    //D . ">>>>", molecule[vertices[0]][]->asString();
    
    var dmax = 0.0D;
    var imax: int;

    var a1 = molecule[vertices[0]];
    for var i = 0 to last(molecule) {
            var a = molecule[i];
            var d = atom_distance( a1, a );
            if( dmax < d ) {
                dmax = d;
                imax = i;
                vertices[1] = i;
            }
        }

    //D . ">>>>", "the most distant second atom is:";
    //D . ">>>>", molecule[vertices[1]][]->asString();

    dmax = 0.0D;
    imax = 0;
    var a2 = molecule[vertices[1]];
    var pt1 = [ a1.x, a1.y, a1.z ];
    var pt2 = [ a2.x, a2.y, a2.z ];

    //D . ">>> a1:", a1->asString();
    //D . ">>> a2:", a2->asString();
    //D . ">>> p1:", pt1;
    //D . ">>> p2:", pt2;

    for var i = 0 to last(molecule) {
            var a = molecule[i];
            var d = line2pt_distance( pt1, pt2, [ a.x, a.y, a.z ] );
            //D . ">>> atom:", a->asString(), "d:", d;
            //D . ">>>   pt:", [ a.x, a.y, a.z ];
            if( dmax < d ) {
                dmax = d;
                imax = i;
                vertices[2] = i;
            }
        }

    //D . ">>>>", "the most distant from the line is:";
    //D . ">>>>", molecule[vertices[2]][]->asString();

    var a3 = molecule[vertices[2]];
    var pt3 = [ a3.x, a3.y, a3.z ];

    dmax = 0.0D;
    for var i = 0 to last(molecule) {
            var a = molecule[i];
            var pt = [a.x, a.y, a.z];
            var d = abs( pl2pt_distance( pt1, pt2, pt3, pt ) );
            if( dmax <= d ) {
                dmax = d;
                vertices[3] = i;
            }
        }

    //D . ">>>>", "the most distant from the plane is:";
    //D . ">>>>", molecule[vertices[3]][]->asString();
    //D . "";

    var a4 = molecule[vertices[3]];

    if( pl2pt_distance( pt1, pt2, pt3, [a4.x, a4.y, a4.z] ) < 0.0D ) {
        vertices[0], vertices[1] = vertices[1], vertices[0];
    }
    
    return vertices;
}

function tetrahedron_faces( tetrahedron: int[]; molecule: Atom[] ): list of Face
{
    var faces = null_Face * new [4];
    var face = null_Face;

    faces[0] = face = new Face;
    face.molecule = molecule;
    face.v1 = tetrahedron[0];
    face.v2 = tetrahedron[1];
    face.v3 = tetrahedron[2];
    
    faces[1] = face = new Face;
    face.molecule = molecule;
    face.v1 = tetrahedron[0];
    face.v2 = tetrahedron[3];
    face.v3 = tetrahedron[1];
    
    faces[2] = face = new Face;
    face.molecule = molecule;
    face.v1 = tetrahedron[1];
    face.v2 = tetrahedron[3];
    face.v3 = tetrahedron[2];
    
    faces[3] = face = new Face;
    face.molecule = molecule;
    face.v1 = tetrahedron[0];
    face.v2 = tetrahedron[2];
    face.v3 = tetrahedron[3];

    // The order of faces in the neighbour list is important!
    faces[0].neighbours = [ faces[1], faces[2], faces[3] ];
    faces[1].neighbours = [ faces[3], faces[2], faces[0] ];
    faces[2].neighbours = [ faces[1], faces[3], faces[0] ];
    faces[3].neighbours = [ faces[0], faces[2], faces[1] ];

    var face_list: list of Face;

    for( var i = last(faces); i >= 0; i -- ) {
        faces[i].edge_crossed = new bool[3];
        face_list = (faces[i],) + face_list;
    }
    
    return face_list;
}

procedure add_vertices_to_outside_set
    ( face: Face; unclaimed_vertices: list of Atom ): list of Atom
{
    var still_unclaimed: list of Atom;

    var mol = face.molecule;
    var a1 = mol[face.v1];
    var a2 = mol[face.v2];
    var a3 = mol[face.v3];
    var pt1 = [a1.x, a1.y, a1.z];
    var pt2 = [a2.x, a2.y, a2.z];
    var pt3 = [a3.x, a3.y, a3.z];

    for var vertex in unclaimed_vertices {
            var pt = [vertex.x, vertex.y, vertex.z];
            var d = pl2pt_distance( pt1, pt2, pt3, pt );
            if( vertex.atomNumber != a1.atomNumber &&
                vertex.atomNumber != a2.atomNumber &&
                vertex.atomNumber != a3.atomNumber ) {
                if( d < 0.0D ) {
                    face.outside_atoms = (vertex,) + face.outside_atoms;
                } else {
                    still_unclaimed = (vertex,) + still_unclaimed;
                }
            }
        }

    return still_unclaimed;
}

function find_nonempty_face( faces: list of Face ): Face
{
    for var face in faces {
            if( face.outside_atoms ) {
                return face;
            }
        }
    return null_Face;
}

function find_eye_point( face: Face ): Atom
{
    var most_distant_atom: Atom = null_Atom;

    var mol = face.molecule;
    var a1 = mol[face.v1];
    var a2 = mol[face.v2];
    var a3 = mol[face.v3];
    var pt1 = [a1.x, a1.y, a1.z];
    var pt2 = [a2.x, a2.y, a2.z];
    var pt3 = [a3.x, a3.y, a3.z];

    var dmax = -1.0D;
    most_distant_atom = face.outside_atoms.value;
    for var atom in face.outside_atoms {
            var pt = [ atom.x, atom.y, atom.z ];
            var d = abs(pl2pt_distance( pt1, pt2, pt3, pt ));
            if( dmax < d ) {
                dmax = d;
                most_distant_atom = atom;
            }
        }

    return most_distant_atom;
}

function minmax( a: array of type X; cmp: function(X a[]; X b[])->(int) ): X[], X[], int, int
{
    var min = a[0];
    var max = a[0];
    var imin, imax: int[];

    for var i = 1 to last(a) {
            var ai = a[i:i];
            if( cmp(min, ai) > 0 ) {
                min = ai;
                imin = i;
            }
            if( cmp(max, ai) < 0 ) {
                max = ai;
                imax = i;
            }
        }
    return min, max, imin, imax
}
