#! /usr/bin/env starta
/*--*- Java -*---------------------------------------------------------------*\
**$Author: saulius $
**$Date: 2019-03-27 10:46:43 +0200 (Wed, 27 Mar 2019) $ 
**$Revision: 5682 $
**$URL: svn+ssh://saulius-grazulis.lt/home/saulius/svn-repositories/paskaitos/VU/software/trunk/bioinformatika-III-assignments/bin/pdbhull $
\*---------------------------------------------------------------------------*/
//
// Starta programa, kuri kiekvienam PDB(x) failui suskaičiuoja jo
// atomų iškiląjį apvalkalėlį. Algoritmas: "gift wrapping".
//
// Programos iškvietimas:
// pdbhull < 1zyx.pdb
// pdbhull 1zyx.pdb 2zyx*.cif
//
//**
    
pragma append  "$P/lib/starta";
pragma prepend "$P/lib";
    
use std;
use Strings;
use BiomoleculeAtom;
use PDBline;
use PDBxline;
use Vectors;

var Id = "$Id: pdbhull 5682 2019-03-27 08:46:43Z saulius $";

. "#", Id[1:-2];

// XAtom is an atom that can be sorted by x coordinates. If x
// coordinates are equal, then y coordinates are taken into account,
// and finally z.

class XAtom : Atom {
    constructor() {}
    constructor fromAtom( Atom a )
    {
        self := a;
    }
    operator ">" ( XAtom a; XAtom b ): bool
    {
        return a.x > b.x ? true :
            (a.x < b.x ? false :
             (a.y > b.y ? true : (a.y < b.y ? false : a.z > b.z)
              )
             );
    }
    operator "<" ( XAtom a; XAtom b ): bool
    {
        return a.x < b.x ? true :
            (a.x > b.x ? false :
             (a.y < b.y ? true : (a.y > b.y ? false : a.z < b.z)
              )
             );
    }
    method asString(): string
    {
        return "%f " %% self.x _ "%f " %% self.y _ "%f " %% self.z _ self.atomName;
    }
};

// Flag which file format we are currently reading:
type format = enum byte( PDB, PDBx );
var current_format = PDB format;

exception FORMAT_ERROR;

var atom = new XAtom();
var molecule: array of XAtom = new XAtom[0];

while(<>) {
    if( strstart( "data_", $_ )) {
        current_format = PDBx format;
        continue;
    }
    if( strstart( "HEADER", $_ ) || strstart( "CRYST1", $_ ) ) {
        current_format = PDB format;
        continue;
    }
    if( current_format == PDB format && strstart( "ATOM  ", $_ ) ||
        current_format == PDBx format && strstart( "ATOM", $_ ) ||
        strstart( "HETATM", $_ )) {
        
        if( current_format == PDB format ) then
            atom = new XAtom.fromAtom( PDBline::split( $_ ));
        elsif( current_format == PDBx format ) then
            atom = new XAtom.fromAtom( PDBxline::split( $_ ));
        else
            raise FORMAT_ERROR( "unsupported format %d" %% current_format@int );
        endif;
        molecule = push( molecule, atom );
    }
}

import HeapSort(XAtom) as SortAtomsByX;
use HeapSortCmp;

function cmpy( a, b: Atom ): int
{
    return a.y < b.y ? -1 : 1;
}

function cmpz( a, b: Atom ): int
{
    return a.z < b.z ? -1 : 1;
}

var sorted_atoms_by_x = SortAtomsByX::sorted( molecule );
// var sorted_atoms_by_y = sorted( molecule, cmpy );
// var sorted_atoms_by_z = sorted( molecule, cmpz );

// for( var a in sorted_atoms ) {
//     . a->asString();
// }

// var N = last(molecule);
// 
// . sorted_atoms_by_x[0]->asString();
// . sorted_atoms_by_x[N]->asString();
// 
// . sorted_atoms_by_y[0]->asString();
// . sorted_atoms_by_y[N]->asString();
// 
// . sorted_atoms_by_z[0]->asString();
// . sorted_atoms_by_z[N]->asString();

// The lowest atoms are definitly in the hull:
var a2 = sorted_atoms_by_x[0];
var a1 = new XAtom.fromAtom( a2 );
a1.x += 1.0D;

var a3 = sorted_atoms_by_x[1];

function det3( double[][] m ): double;
function det4( double[][] m ): double;

var v1 = [a1.x,a1.y,a1.z,1.0D];
var v2 = [a2.x,a2.y,a2.z,1.0D];
var v3 = [a3.x,a3.y,a3.z,1.0D];

var ch_index: int;

for var i = 2 to last(sorted_atoms_by_x) {
        var a4 = sorted_atoms_by_x[i];
        var v4 = [a4.x,a4.y,a4.z,1.0D];
        var d = det4( [v1, v2, v3, v4] );
        if( d < 0.0D ) {
            a3 = a4;
            v3 = [a3.x,a3.y,a3.z,1.0D];
            ch_index = i;
        }
    };

// Now a2, a3 are on the covex hull.

a1 = a2;
a2 = a3;

// . a1->asString();
// . a2->asString();

var hull = new Atom[0];
var in_hull = new bool[length(sorted_atoms_by_x)];

in_hull[0] = true;
in_hull[ch_index] = true;

hull = push( hull, a1 );
hull = push( hull, a2 );

var b1 = a1;
var b2 = a2;

repeat {
    v1 = [b1.x,b1.y,b1.z,1.0D];
    v2 = [b2.x,b2.y,b2.z,1.0D];
    var b3 = sorted_atoms_by_x[0];
    for( var i = 1; i < last(sorted_atoms_by_x); i++ ) {
        if( !in_hull[i] ) {
            b3 = sorted_atoms_by_x[i];
            ch_index = i;
            break;
        }
    }
    if( b3 == sorted_atoms_by_x[0] ) {
        break;
    }
    v3 = [b3.x,b3.y,b3.z,1.0D];
    ch_index = 0;
    for var i = 1 to last(sorted_atoms_by_x) {
            if( in_hull[i] ) {
                continue;
            }
            var b4 = sorted_atoms_by_x[i];
            var v4 = [b4.x,b4.y,b4.z,1.0D];
            var d = det4( [v1, v2, v3, v4] );
            if( d < 0.0D ) {
                b3 = b4;
                v3 = v4;
                ch_index = i;
            }
        }
    if( in_hull[ch_index] ) {
        break;
    }
    in_hull[ch_index] = true;
    hull = push( hull, b3 );
    b1 = b2;
    b2 = b3;
} while( length(hull) < 400 );

for( var a in hull ) {
    . a->asString();
}

//------------------------------------------------------------------------------

function minor3( double m[][]; k, l: int ): double[][]
{
    var minor = new double[3][3];
    var ii, jj: int;
    for( var i = 0; i < 4; i ++ ) {
        if( i == k ) {
            continue;
        }
        jj = 0;
        for( var j = 0; j < 4; j ++ ) {
            if( j == l ) {
                continue;
            }
            minor[ii][jj] = m[i][j];
            jj++;
        }
        ii++
    }
    return minor;
}

function det4( double[][] m ): double
{
    var det: double;

    return
        m[0][0] * det3(minor3(m,0,0)) -
        m[0][1] * det3(minor3(m,0,1)) +
        m[0][2] * det3(minor3(m,0,2)) -
        m[0][3] * det3(minor3(m,0,3));
}

function det3( s : double[][] ): double
{
    return
        + s[0][0] * s[1][1] * s[2][2]
        + s[1][0] * s[2][1] * s[0][2]
        + s[0][1] * s[1][2] * s[2][0]

        - s[0][2] * s[1][1] * s[2][0]
        - s[0][0] * s[1][2] * s[2][1]
        - s[0][1] * s[1][0] * s[2][2];
}
