/*--*-C-*--------------------------------------------------------------------*\
**$Author$
**$Date$ 
**$Revision$
**$URL$
\*---------------------------------------------------------------------------*/

/* private allocator for tnodes */

#include <stdlib.h>
#include <cexceptions.h>
#include <allocx.h>

#if 0
#define USE_FIXED_NODE_ARRAY
#endif

/* The doubly-linked list of allocated TNODEs: */
static TNODE *allocated = NULL;
static intmax_t maxalloc;

static void tnode_exclude_from_allocated_list( TNODE *tnode )
{
    if( tnode ) {
        if( allocated == tnode ) {
            allocated = tnode->next_alloc;
        }
        if( tnode->prev_alloc ) {
            assert( tnode->prev_alloc->next_alloc == tnode );
            tnode->prev_alloc->next_alloc = tnode->next_alloc;
        }
        if( tnode->next_alloc ) {
            assert( tnode->next_alloc->prev_alloc == tnode );
            tnode->next_alloc->prev_alloc = tnode->prev_alloc;
        }
    }
}

#ifdef USE_FIXED_NODE_ARRAY

#define MAX_TNODES 100000

static TNODE tnodes[MAX_TNODES];
static long last_tnode;

static TNODE *alloc_tnode( cexception_t *ex )
{
    /* return callocx( sizeof(TNODE), 1, ex ); */
    assert( last_tnode < MAX_TNODES );
    /* printf( "allocating tnode %ld\n", last_tnode ); */
    TNODE *node = &tnodes[last_tnode++];
    if( allocated ) {
        allocated->prev_alloc = node;
    }
    node->next_alloc = allocated;
    allocated = node;
    maxalloc ++;
    return node;
}

static void free_tnode( TNODE *tnode )
{
    /* freex( tnode ); return; */
    /* printf( "deleting tnode %d\n", (tnode-tnodes) ); */
    assert( tnode->rcount == 0 );
    tnode_exclude_from_allocated_list( tnode );
    tnode->rcount--;
}

void deallocate_all_tnodes( void )
{
    TNODE *node, *next;
    for( node = allocated; node != NULL; ) {
        next = node->next;
        deallocate_tnode_buffers( node );
        node = next;
    }
    allocated = NULL;
}

#else

static TNODE *alloc_tnode( cexception_t *ex )
{
    TNODE *node = callocx( sizeof(TNODE), 1, ex );
#if 1
    if( allocated ) {
        allocated->prev_alloc = node;
    }
    node->next_alloc = allocated;
    allocated = node;
#endif
    maxalloc ++;
    node->serno = maxalloc;
    //printf( ">>>> allocating tnode no %zd\n", maxalloc ); 
    return node;
}

static void free_tnode( TNODE *tnode )
{
    assert( tnode->rcount == 0 );
    //printf( "<<<<< freeing tnode %zd\n", tnode->serno ); 
    tnode_exclude_from_allocated_list( tnode );
    freex( tnode );
}

void deallocate_all_tnodes( void )
{
    TNODE *node, *next;
    for( node = allocated; node != NULL; ) {
        next = node->next;
        deallocate_tnode_buffers( node );
        freex( node );
        node = next;
    }
    allocated = NULL;
}

#endif

void tnode_print_allocated()
{
    tnode_fprint_allocated( stdout );
}

void tnode_print_allocated_to_stderr()
{
    tnode_fprint_allocated( stderr );
}

void tnode_fprint_allocated( FILE *fp )
{
    TNODE *node;
    fprintf( fp, "MAX TNODES: %jd\n", maxalloc );
    for( node = allocated; node != NULL; node = node->next_alloc ) {
        fprintf( fp, "TNODE: %p \"%s\" base type = \"%s\" rcount = %zd "
                 "next = %p\n", node, node->name,
                 node->base_type ? tnode_name( node->base_type ) : "",
                 node->rcount, node->next );
    }
}
