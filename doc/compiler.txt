Какой компилятор хотелось бы иметь мне?

Несмотря на большое количество созданных языков и компиляторов, ни
один из них не кажется полностью удовлетворительным. Хотя многие языки
и компиляторы предоставляют много нужных (и еще больше ненужных)
разработчику программ средств, нет в мире изделия, сочетающего в себе
все желательные свойства, пусть даже в ущерб некоторым второстепенным
особенностям. Здесь сделана попытка перечислить все те свойства
компилятора, которые очень хотелось бы иметь собранными вместе в одной
программе, а также обсуждаются возможности реализации такого
компилятора ограниченными ресурсами.

Желательные свойства компилятора

1. Простота в использовании и изготовлении.

Язык, на котором пишется программа, должен быть простым. На первый
взгляд кажется, что это требование вызвано исключительно желанием
сделать компилятор малыми затратами сил и времени. Однако наблюдение
за событиями в програмистском мире наводят на мысль, что сложность
языка создает проблемы, с которым непросто справиться даже солидным
фирмам, таким как Microsoft или Borland, хотя у них - то, казалось бы,
ресурсов предостаточно. Опыт испоьзования C++ показывает, что для
столь сложного языка компилятор получается большим, медленным и
содержит множество ошибок. С другой стороны, Turbo Pascal фирмы
Borland куда более надежное и безошибочное изделие. Я предполагаю, что
простота и непритязательность Pascal'я сыграла здесь ключевую
роль. Простой компилятор простого языка намного легче обозреть, найти
в нем ошибки, протестировать и проверифицировать (хотя бы
полуформально).

2. Надежность и безошибочность.

Как уже упоминалось выше, простота языка влечет за собой простоту
компилятора, а простота компилятора помогет сделать его более
качественно. Думаю, при достаточно аккуратном проектировании можно
сделать очень наджным.  Достаточные выразительные средства

Требования к языку

1.	Язык должен быть объектным.

            Деструкторы должны вызываться автоматически при
	    уничтожении объектов. Должны ли автоматически вызываться
	    конструкторы, пока не ясно.

2.	Хорошая модульность
3.	Развитая система типов
4.	Множественное наследование?
5.	Переопределение операторов
6.	Поддержка прошлого кода !?
7.	Обработка исключении !!!
8.	Встроенная поддержка списков и полиморфных контейнеров ?
9.	Структуры управления
10.	Сборка мусора наряду с управляемой деаллокацией ?
11.	Поддержка переопределения собственных библиотек
12.	Поддержка работы со строками
13.	Хороший оптимизатор
14.	Поддержка родовых модулей?
15.	Наличие встроенного ассемблера
16.	Поддержка inline процедур

